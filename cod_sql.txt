
-- Exercitiul 4






-- ============================================================
-- SCRIPT: ERD simplificat (CREATE + DROP)
-- Entitati: Angajati, Clienti, Comenzi, Produse, Oferte, Evenimente,
--           Sali, Rezervari, Animatori
-- Relatii implementate (tabele asociative):
--   - Planificari_organizatorice (Angajati x Evenimente x Sali)
--   - Comenzi_Angajati (Comenzi x Angajati)
--   - Comenzi_Produse (Comenzi x Produse)
--   - Liste_reduceri (Oferte x Produse)
--   - Evenimente_Produse (Evenimente x Produse)
--   - Colaborari (Evenimente x Animatori)
--   - Participari_evenimente (Clienti x Evenimente)
-- ============================================================

-- =========================
-- DROP (ordine sigura)
-- =========================
DROP TABLE Planificari_organizatorice CASCADE CONSTRAINTS;
DROP TABLE Participari_evenimente CASCADE CONSTRAINTS;
DROP TABLE Colaborari CASCADE CONSTRAINTS;
DROP TABLE Evenimente_Produse CASCADE CONSTRAINTS;
DROP TABLE Liste_reduceri CASCADE CONSTRAINTS;
DROP TABLE Comenzi_Angajati CASCADE CONSTRAINTS;
DROP TABLE Comenzi_Produse CASCADE CONSTRAINTS;

DROP TABLE Rezervari CASCADE CONSTRAINTS;
DROP TABLE Comenzi CASCADE CONSTRAINTS;

DROP TABLE Animatori CASCADE CONSTRAINTS;
DROP TABLE Oferte CASCADE CONSTRAINTS;
DROP TABLE Produse CASCADE CONSTRAINTS;
DROP TABLE Evenimente CASCADE CONSTRAINTS;
DROP TABLE Sali CASCADE CONSTRAINTS;
DROP TABLE Clienti CASCADE CONSTRAINTS;
DROP TABLE Angajati CASCADE CONSTRAINTS;

-- =========================
-- CREATE (entitati baza)
-- =========================

CREATE TABLE Angajati (
    id_angajat      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nume            VARCHAR2(50)  NOT NULL,
    prenume         VARCHAR2(50)  NOT NULL,
    functie         VARCHAR2(50)  NOT NULL,
    salariu         NUMBER(10,2)  NOT NULL CHECK (salariu > 0),
    data_angajare   DATE          DEFAULT SYSDATE NOT NULL,
    mail            VARCHAR2(100) NOT NULL
    -- CONSTRAINT uq_angajati_mail UNIQUE (mail)
);

CREATE TABLE Clienti (
    id_client   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nume        VARCHAR2(50)  NOT NULL,
    prenume     VARCHAR2(50)  NOT NULL,
    nr_tel      VARCHAR2(15)  NOT NULL,
    mail        VARCHAR2(100) NOT NULL
    -- CONSTRAINT uq_clienti_mail UNIQUE (mail)
);

CREATE TABLE Sali (
    id_sala     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nume_sala   VARCHAR2(50) NOT NULL,
    capacitate  NUMBER       NOT NULL CHECK (capacitate > 0)
);

CREATE TABLE Evenimente (
    id_eveniment     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tip_eveniment    VARCHAR2(50) NOT NULL,
    data_eveniment   DATE         NOT NULL,
    numar_persoane   NUMBER       NOT NULL CHECK (numar_persoane > 0)
);

CREATE TABLE Animatori (
    id_animator    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nume_animator  VARCHAR2(50) NOT NULL,
    tip_activitate VARCHAR2(50) NOT NULL,
    pret_ora       NUMBER(10,2) NOT NULL CHECK (pret_ora > 0)
);

CREATE TABLE Oferte (
    id_oferta      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    discount       NUMBER(5,2) NOT NULL CHECK (discount >= 0 AND discount <= 100),
    data_expirare  DATE        NOT NULL
);

CREATE TABLE Produse (
    id_produs        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nume_produs      VARCHAR2(50) NOT NULL,
    cantitate        NUMBER       NOT NULL CHECK (cantitate >= 0),
    unitate_masura   VARCHAR2(20) NOT NULL CHECK (unitate_masura IN ('buc', 'portie', 'sticla', 'pahar')),
    pret_unitar      NUMBER(10,2) NOT NULL CHECK (pret_unitar > 0)
);

CREATE TABLE Rezervari (
    id_rezervare     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    data_rezervare   DATE         NOT NULL,
    ora_rezervare    VARCHAR2(10)  NOT NULL
        CHECK ( REGEXP_LIKE(ora_rezervare, '^([0-1][0-9]|2[0-3]):[0-5][0-9]$') ),
    numar_persoane   NUMBER        NOT NULL CHECK (numar_persoane > 0),
    id_client        NUMBER        NOT NULL,
    id_sala          NUMBER        NOT NULL,
    CONSTRAINT fk_rez_client FOREIGN KEY (id_client) REFERENCES Clienti(id_client),
    CONSTRAINT fk_rez_sala   FOREIGN KEY (id_sala)   REFERENCES Sali(id_sala)
);

CREATE TABLE Comenzi (
    id_comanda     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    data_comanda   DATE         DEFAULT SYSDATE NOT NULL,
    status         VARCHAR2(50) NOT NULL
        CHECK (status IN ('in redactare', 'plasata', 'in curs de preparare', 'platita', 'anulata')),
    -- pret_total     NUMBER(10,2) NOT NULL CHECK (pret_total >= 0),
    id_client      NUMBER       NOT NULL,
    CONSTRAINT fk_com_client FOREIGN KEY (id_client) REFERENCES Clienti(id_client)
);

-- =========================
-- CREATE (relatii / tabele asociative)
-- =========================

-- Comenzi M:N Produse (o comanda contine produse)
CREATE TABLE Comenzi_Produse (
    id_comanda  NUMBER NOT NULL,
    id_produs   NUMBER NOT NULL,
    cantitate   NUMBER NOT NULL CHECK (cantitate > 0),
    PRIMARY KEY (id_comanda, id_produs),
    CONSTRAINT fk_cp_comanda FOREIGN KEY (id_comanda) REFERENCES Comenzi(id_comanda),
    CONSTRAINT fk_cp_produs  FOREIGN KEY (id_produs)  REFERENCES Produse(id_produs)
);

-- Comenzi M:N Angajati (o comanda este preluata/gestionata de angajati)
CREATE TABLE Comenzi_Angajati (
    id_comanda  NUMBER NOT NULL,
    id_angajat  NUMBER NOT NULL,
    rol         VARCHAR2(30),
    PRIMARY KEY (id_comanda, id_angajat),
    CONSTRAINT fk_ca_comanda FOREIGN KEY (id_comanda) REFERENCES Comenzi(id_comanda),
    CONSTRAINT fk_ca_angajat FOREIGN KEY (id_angajat) REFERENCES Angajati(id_angajat)
);

-- Oferte M:N Produse (produse incluse intr-o oferta)
CREATE TABLE Liste_reduceri (
    id_oferta  NUMBER NOT NULL,
    id_produs  NUMBER NOT NULL,
    PRIMARY KEY (id_oferta, id_produs),
    CONSTRAINT fk_lr_oferta FOREIGN KEY (id_oferta) REFERENCES Oferte(id_oferta),
    CONSTRAINT fk_lr_produs FOREIGN KEY (id_produs) REFERENCES Produse(id_produs)
);

-- Evenimente M:N Produse (produse necesare la un eveniment)
CREATE TABLE Evenimente_Produse (
    id_eveniment NUMBER NOT NULL,
    id_produs    NUMBER NOT NULL,
    cantitate    NUMBER NOT NULL CHECK (cantitate > 0),
    PRIMARY KEY (id_eveniment, id_produs),
    CONSTRAINT fk_ep_eveniment FOREIGN KEY (id_eveniment) REFERENCES Evenimente(id_eveniment),
    CONSTRAINT fk_ep_produs    FOREIGN KEY (id_produs)    REFERENCES Produse(id_produs)
);

-- Evenimente M:N Animatori (colaborari)
CREATE TABLE Colaborari (
    id_eveniment NUMBER NOT NULL,
    id_animator  NUMBER NOT NULL,
    numar_ore NUMBER NOT NULL,
    PRIMARY KEY (id_eveniment, id_animator),
    CONSTRAINT fk_col_eveniment FOREIGN KEY (id_eveniment) REFERENCES Evenimente(id_eveniment),
    CONSTRAINT fk_col_animator  FOREIGN KEY (id_animator)  REFERENCES Animatori(id_animator)
);

-- Clienti M:N Evenimente (participari)
CREATE TABLE Participari_evenimente (
    id_eveniment NUMBER NOT NULL,
    id_client    NUMBER NOT NULL,
    PRIMARY KEY (id_eveniment, id_client),
    CONSTRAINT fk_pe_eveniment FOREIGN KEY (id_eveniment) REFERENCES Evenimente(id_eveniment),
    CONSTRAINT fk_pe_client    FOREIGN KEY (id_client)    REFERENCES Clienti(id_client)
);

-- Relatie ternara: Angajati x Evenimente x Sali (planificari organizatorice)
CREATE TABLE Planificari_organizatorice (
    id_angajat   NUMBER NOT NULL,
    id_eveniment NUMBER NOT NULL,
    id_sala      NUMBER NOT NULL,
    observatii   VARCHAR2(200),
    PRIMARY KEY (id_angajat, id_eveniment, id_sala),
    CONSTRAINT fk_po_angajat   FOREIGN KEY (id_angajat)   REFERENCES Angajati(id_angajat),
    CONSTRAINT fk_po_eveniment FOREIGN KEY (id_eveniment) REFERENCES Evenimente(id_eveniment),
    CONSTRAINT fk_po_sala      FOREIGN KEY (id_sala)      REFERENCES Sali(id_sala)
);








-- Exercitiul 5








-- ============================================================
-- Inserare date coerente - schema ERD simplificata (Oracle)
-- 7 randuri pentru fiecare tabela de baza; 12 pentru asociative
-- ============================================================
SET DEFINE OFF;

-- =========================
-- ANGAJATI (7)
-- =========================
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Popescu', 'Andrei', 'Manager', 7500, DATE '2024-03-15', 'andrei.popescu@BellaIta.ro');
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Ionescu', 'Maria', 'Chelner', 4200, DATE '2024-06-01', 'maria.ionescu@BellaIta.ro');
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Dumitru', 'Vlad', 'Bucatar', 5200, DATE '2023-11-10', 'vlad.dumitru@BellaIta.ro');
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Stan', 'Ioana', 'Barman', 4500, DATE '2024-02-20', 'ioana.stan@BellaIta.ro');
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Georgescu', 'Radu', 'Host', 3800, DATE '2024-09-05', 'radu.georgescu@BellaIta.ro');
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Marin', 'Elena', 'Coordonator evenimente', 6000, DATE '2023-07-12', 'elena.marin@BellaIta.ro');
INSERT INTO Angajati (nume, prenume, functie, salariu, data_angajare, mail) VALUES ('Toma', 'Mihai', 'Curier', 3600, DATE '2024-01-08', 'mihai.toma@BellaIta.ro');

-- =========================
-- CLIENTI (7)
-- =========================
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Popa', 'Ana', '0711001100', 'ana.popa@gmail.com');
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Rusu', 'Bogdan', '0722002200', 'bogdan.rusu@gmail.com');
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Munteanu', 'Ioana', '0733003300', 'ioana.munteanu@gmail.com');
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Ilie', 'Cristian', '0744004400', 'cristian.ilie@gmail.com');
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Sandu', 'Daria', '0755005500', 'daria.sandu@gmail.com');
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Lazar', 'Paul', '0766006600', 'paul.lazar@gmail.com');
INSERT INTO Clienti (nume, prenume, nr_tel, mail) VALUES ('Neagu', 'Teodora', '0777007700', 'teodora.neagu@gmail.com');

-- =========================
-- SALI (7)
-- =========================
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Sala Mare', 200);
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Sala VIP', 60);
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Terasa', 120);
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Salon Rustic', 80);
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Sala Conferinte', 100);
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Salon Family', 40);
INSERT INTO Sali (nume_sala, capacitate) VALUES ('Gradina', 150);

-- =========================
-- EVENIMENTE (7)
-- =========================
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('nunta', DATE '2026-02-14', 150);
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('botez', DATE '2026-01-25', 60);
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('corporate', DATE '2026-03-05', 90);
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('aniversare', DATE '2026-01-18', 30);
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('petrecere copii', DATE '2026-02-01', 45);
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('majorat', DATE '2026-02-21', 70);
INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('team building', DATE '2026-03-20', 110);

-- =========================
-- ANIMATORI (7)
-- =========================
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Dinu Ion', 'DJ', 300);
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Popescu Marcel', 'Magician', 450);
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Mocanu Alina', 'Animatoare copii', 250);
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Aleandru Tudor', 'Prezentatoare', 350);
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Ionescu Roxana', 'Lider echipa dansatori', 500);
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Ciubotaru Vlad', 'Fotograf', 400);
INSERT INTO Animatori (nume_animator, tip_activitate, pret_ora) VALUES ('Lungu Sorin', 'Lider trupa live', 650);

-- =========================
-- OFERTE (7)
-- =========================
INSERT INTO Oferte (discount, data_expirare) VALUES (10, DATE '2026-03-31');
INSERT INTO Oferte (discount, data_expirare) VALUES (15, DATE '2026-02-28');
INSERT INTO Oferte (discount, data_expirare) VALUES (20, DATE '2026-01-31');
INSERT INTO Oferte (discount, data_expirare) VALUES (5, DATE '2026-04-30');
INSERT INTO Oferte (discount, data_expirare) VALUES (12.5, DATE '2026-03-15');
INSERT INTO Oferte (discount, data_expirare) VALUES (25, DATE '2026-02-15');
INSERT INTO Oferte (discount, data_expirare) VALUES (8, DATE '2026-05-31');

-- =========================
-- PRODUSE (7)
-- =========================
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Pizza Margherita', 400, 'portie', 32.5);
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Paste Carbonara', 200, 'portie', 38.0);
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Apa plata 0.5L', 500, 'sticla', 8.5);
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Suc natural', 250, 'pahar', 12.0);
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Bere draft', 400, 'pahar', 10.0);
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Desert Tiramisu', 150, 'portie', 22.0);
INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar) VALUES ('Cafea espresso', 40, 'buc', 9.0);

-- =========================
-- REZERVARI (7)
-- =========================
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-10', '00:00', 4, 1, 6);
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-11', '20:00', 2, 2, 2);
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-12', '19:15', 6, 3, 1);
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-13', '13:00', 3, 4, 4);
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-14', '21:45', 5, 5, 3);
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-15', '01:03', 2, 6, 2);
INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala) VALUES (DATE '2026-01-16', '12:30', 8, 7, 7);

-- =========================
-- COMENZI (7) 
-- =========================
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-10', 'plasata', 1);
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-10', 'in curs de preparare', 2);
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-11', 'platita', 3);
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-11', 'plasata', 4);
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-12', 'anulata', 5);
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-12', 'platita', 6);
INSERT INTO Comenzi (data_comanda, status, id_client) VALUES (DATE '2026-01-13', 'plasata', 7);

-- =========================
-- COMENZI_PRODUSE (12)
-- =========================
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (1, 1, 2);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (1, 3, 2);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (2, 2, 1);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (2, 5, 2);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (3, 6, 2);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (3, 7, 2);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (4, 1, 1);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (4, 4, 2);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (5, 2, 1);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (5, 3, 1);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (6, 1, 3);
INSERT INTO Comenzi_Produse (id_comanda, id_produs, cantitate) VALUES (7, 7, 2);

-- =========================
-- COMENZI_ANGAJATI (12)
-- =========================
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (1, 2);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (1, 3);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (2, 2);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (2, 4);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (3, 2);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (3, 3);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (4, 5);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (4, 3);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (5, 2);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (6, 4);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (6, 2);
INSERT INTO Comenzi_Angajati (id_comanda, id_angajat) VALUES (7, 7);

-- =========================
-- LISTE_REDUCERI (12)
-- =========================
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (1, 1);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (1, 2);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (2, 3);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (2, 4);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (3, 5);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (3, 6);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (4, 7);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (5, 1);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (5, 6);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (6, 2);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (6, 5);
INSERT INTO Liste_reduceri (id_oferta, id_produs) VALUES (7, 3);

-- =========================
-- EVENIMENTE_PRODUSE (12)
-- =========================
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (1, 3, 150);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (1, 5, 120);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (2, 3, 60);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (2, 6, 40);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (3, 3, 90);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (3, 4, 80);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (4, 1, 20);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (4, 7, 25);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (5, 4, 60);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (6, 5, 90);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (6, 6, 50);
INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (7, 3, 110);

-- =========================
-- COLABORARI (12)
-- =========================
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (1, 1, 6);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (1, 4, 6);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (2, 6, 4);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (3, 7, 5);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (4, 2, 2);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (5, 3, 4);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (6, 1, 5);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (6, 5, 3);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (7, 4, 4);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (3, 6, 4);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (2, 3, 3);
INSERT INTO Colaborari (id_eveniment, id_animator, numar_ore) VALUES (7, 7, 6);

-- =========================
-- PARTICIPARI_EVENIMENTE (12)
-- =========================
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (1, 1);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (1, 2);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (2, 3);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (2, 4);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (3, 5);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (3, 6);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (4, 7);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (5, 1);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (5, 3);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (6, 2);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (6, 4);
INSERT INTO Participari_evenimente (id_eveniment, id_client) VALUES (7, 6);

-- =========================
-- PLANIFICARI_ORGANIZATORICE (12)
-- =========================
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (2, 1, 1, 'servire sala mare');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (3, 1, 1, 'coordonare meniu');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (6, 1, 1, 'organizare generala');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (5, 2, 2, 'primire invitati');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (2, 3, 5, 'servire coffee break');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (6, 3, 5, 'logistica eveniment');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (4, 4, 4, 'bar eveniment');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (3, 5, 6, 'meniu copii');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (6, 5, 6, 'management activitati');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (2, 6, 3, 'servire terasa');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (4, 6, 3, 'bar terasa');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (6, 7, 7, 'organizare outdoor');

COMMIT;










-- Exercitiul 6






-- ============================================================
-- PUNCTUL 6 (Proiect SGBD 2025-2026)
-- Subprogram stocat independent care utilizeaza toate cele 3 tipuri de colectii:
--   (1) VARRAY
--   (2) NESTED TABLE
--   (3) ASSOCIATIVE ARRAY (INDEX BY)
--
-- Problema (in limbaj natural, adaptata bazei de date):
--   Pentru un eveniment dat (id_eveniment), sa se genereze un raport logistic care:
--     - afiseaza detalii despre eveniment (tip, data, numar_persoane);
--     - calculeaza capacitatea totala a salilor alocate evenimentului;
--     - listeaza produsele necesare evenimentului (cantitati) si verifica daca stocul este suficient;
--     - calculeaza costul estimat pentru produsele necesare;
--     - afiseaza alerte (ex: stoc insuficient, capacitate insuficienta, lipsa planificare).
--
-- Implementare colectii:
--   - NESTED TABLE: lista de id-uri de produse folosite la eveniment (din Evenimente_Produse)
--   - ASSOCIATIVE ARRAY: mapare id_produs -> cantitate_necesara
--   - VARRAY: lista (max 10) de mesaje de alerta
-- ============================================================

-- SET SERVEROUTPUT ON;

-- DROP TYPE t_alerte FORCE
-- DROP TYPE t_lista_produse FORCE


-- (1) VARRAY: lista fixa de alerte
CREATE OR REPLACE TYPE t_alerte IS VARRAY(10) OF VARCHAR2(200);
/
-- (2) NESTED TABLE: lista de id-uri de produse pentru eveniment
CREATE OR REPLACE TYPE t_lista_produse IS TABLE OF NUMBER;
/

CREATE OR REPLACE PROCEDURE raport_logistic_eveniment(
    p_id_eveniment IN NUMBER
) AS
    
    -- (3) ASSOCIATIVE ARRAY: mapare id_produs -> cantitate necesara
    TYPE t_necesar_map IS TABLE OF NUMBER INDEX BY PLS_INTEGER;

    v_alerte        t_alerte := t_alerte();
    v_id_produse    t_lista_produse := t_lista_produse();
    v_necesar       t_necesar_map;

    v_tip_eveniment  Evenimente.tip_eveniment%TYPE;
    v_data_eveniment Evenimente.data_eveniment%TYPE;
    v_nr_pers        Evenimente.numar_persoane%TYPE;

    v_cap_totala     NUMBER := 0;
    v_participanti   NUMBER := 0;

    v_cost_produse   NUMBER := 0;
    -- v_cost_animatori NUMBER := 0;

    PROCEDURE add_alert(p_msg IN VARCHAR2) IS
    BEGIN
        IF v_alerte.COUNT < v_alerte.LIMIT THEN
            v_alerte.EXTEND;
            v_alerte(v_alerte.COUNT) := p_msg;
        END IF;
    END;

BEGIN
    -- 1) Detalii eveniment
    BEGIN
        SELECT tip_eveniment, data_eveniment, numar_persoane
        INTO   v_tip_eveniment, v_data_eveniment, v_nr_pers
        FROM   Evenimente
        WHERE  id_eveniment = p_id_eveniment;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Nu exista eveniment cu id_eveniment = ' || p_id_eveniment);
            RETURN;
    END;

    DBMS_OUTPUT.PUT_LINE('============================================================');
    DBMS_OUTPUT.PUT_LINE('RAPORT LOGISTIC - Eveniment #' || p_id_eveniment);
    DBMS_OUTPUT.PUT_LINE('Tip: ' || v_tip_eveniment || ' | Data: ' || TO_CHAR(v_data_eveniment, 'YYYY-MM-DD') ||
                         ' | Nr. persoane: ' || v_nr_pers);
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');

    -- 2) Capacitate totala a salilor alocate (distinct)
    SELECT NVL(SUM(s.capacitate), 0)
    INTO   v_cap_totala
    FROM   Sali s
    WHERE  s.id_sala IN (
        SELECT DISTINCT po.id_sala
        FROM Planificari_organizatorice po
        WHERE po.id_eveniment = p_id_eveniment
    );

    IF v_cap_totala = 0 THEN
        add_alert('Nu exista sali alocate (Planificari_organizatorice) pentru acest eveniment.');
    ELSIF v_nr_pers > v_cap_totala THEN
        add_alert('Capacitate insuficienta: ' || v_cap_totala || ' locuri pentru ' || v_nr_pers || ' persoane.');
    END IF;

    -- 3) Numar participanti inscrisi (din participari)
    SELECT COUNT(*)
    INTO   v_participanti
    FROM   Participari_evenimente
    WHERE  id_eveniment = p_id_eveniment;

    DBMS_OUTPUT.PUT_LINE('Capacitate sali (total): ' || v_cap_totala);
    DBMS_OUTPUT.PUT_LINE('Participanti inregistrati: ' || v_participanti);

    -- 5) Colectare produse necesare (NESTED TABLE) + mapare cantitati (ASSOCIATIVE)
    SELECT ep.id_produs
    BULK COLLECT INTO v_id_produse
    FROM Evenimente_Produse ep
    WHERE ep.id_eveniment = p_id_eveniment
    ORDER BY ep.id_produs;

    FOR ep IN (
        SELECT id_produs, cantitate
        FROM Evenimente_Produse
        WHERE id_eveniment = p_id_eveniment
    ) LOOP
        v_necesar(ep.id_produs) := ep.cantitate;
    END LOOP;

    IF v_id_produse.COUNT = 0 THEN
        add_alert('Nu exista produse asociate evenimentului (Evenimente_Produse).');
    END IF;

    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('Produse necesare (necesar vs stoc):');

    -- Folosim NESTED TABLE in SQL: TABLE(v_id_produse)
    FOR p IN (
        SELECT p2.id_produs, p2.nume_produs, p2.cantitate AS stoc,
               p2.unitate_masura, p2.pret_unitar
        FROM Produse p2
        WHERE p2.id_produs IN (SELECT COLUMN_VALUE FROM TABLE(v_id_produse))
        ORDER BY p2.id_produs
    ) LOOP
        DECLARE
            v_req NUMBER;
        BEGIN
            v_req := NVL(v_necesar(p.id_produs), 0);
            v_cost_produse := v_cost_produse + (v_req * p.pret_unitar);

            DBMS_OUTPUT.PUT_LINE(' - #' || p.id_produs || ' ' || RPAD(p.nume_produs, 20) ||
                                 ' necesar=' || TO_CHAR(v_req) || ' ' || p.unitate_masura ||
                                 ' | stoc=' || TO_CHAR(p.stoc) || ' ' || p.unitate_masura ||
                                 ' | pret_unitar=' || TO_CHAR(p.pret_unitar));

            IF v_req > p.stoc THEN
                add_alert('Stoc insuficient pentru produsul "' || p.nume_produs || '": necesar ' || v_req ||
                          ', stoc ' || p.stoc || '.');
            END IF;
        END;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Cost estimat produse (necesar * pret_unitar): ' || TO_CHAR(v_cost_produse, '9999990D00'));

    -- 7) Afisare alerte (VARRAY)
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');
    IF v_alerte.COUNT = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Alerte: (niciuna)');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Alerte (' || v_alerte.COUNT || '):');
        FOR i IN 1 .. v_alerte.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE(' ! ' || v_alerte(i));
        END LOOP;
    END IF;

    DBMS_OUTPUT.PUT_LINE('============================================================');

END;
/

-- ============================================================
-- APEL (exemplu) 
-- ============================================================
BEGIN
    raport_logistic_eveniment(7);
END;
/


SET SERVEROUTPUT ON;

DECLARE
  v_evt_fara_tot     NUMBER;
  v_evt_cap_stoc     NUMBER;
  v_sala_mica        NUMBER;
  v_ang              NUMBER;
  v_prod             NUMBER;
  v_mail             VARCHAR2(200);
BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST PUNCTUL 6 =================');
  SAVEPOINT sp6;

  -- Caz 1: eveniment inexistent (NO_DATA_FOUND tratat in procedura)
  DBMS_OUTPUT.PUT_LINE('--- Caz 1: eveniment inexistent ---');
  raport_logistic_eveniment(-1);
  raport_logistic_eveniment(NULL);

  -- Caz 2: eveniment existent, dar fara sali + fara produse (alerte)
  DBMS_OUTPUT.PUT_LINE('--- Caz 2: fara sali + fara produse ---');
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST_P6_FARA', DATE '2099-01-01', 10)
  RETURNING id_eveniment INTO v_evt_fara_tot;

  raport_logistic_eveniment(v_evt_fara_tot);

  -- Caz 3: capacitate insuficienta + stoc insuficient (alerte)
  DBMS_OUTPUT.PUT_LINE('--- Caz 3: capacitate insuficienta + stoc insuficient ---');

  INSERT INTO Sali (nume_sala, capacitate)
  VALUES ('SALA_TEST_P6', 5)
  RETURNING id_sala INTO v_sala_mica;

  v_mail := 'p6_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com';
  INSERT INTO Angajati (nume, prenume, functie, salariu, mail)
  VALUES ('Test', 'P6', 'Chelner', 3000, v_mail)
  RETURNING id_angajat INTO v_ang;

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST_P6_CAP_STOC', DATE '2099-01-02', 50)
  RETURNING id_eveniment INTO v_evt_cap_stoc;

  -- (daca la tine PK la planificari e (id_angajat,id_eveniment) e ok; daca e pe 3 coloane, e tot ok)
  INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii)
  VALUES (v_ang, v_evt_cap_stoc, v_sala_mica, 'test capacitate');

  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('PROD_TEST_P6', 1, 'buc', 10)
  RETURNING id_produs INTO v_prod;

  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate)
  VALUES (v_evt_cap_stoc, v_prod, 10);

  raport_logistic_eveniment(v_evt_cap_stoc);

  ROLLBACK TO sp6;
  DBMS_OUTPUT.PUT_LINE('===================================================');
END;
/

SET SERVEROUTPUT ON;

DECLARE
  v_evt_test NUMBER;
  v_tip      Evenimente.tip_eveniment%TYPE;

  PROCEDURE safe_exec(p_sql VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE p_sql;
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('   [WARN] ' || p_sql || ' -> ' || SQLERRM);
  END;

  PROCEDURE safe_count(p_table VARCHAR2) IS
    v_cnt NUMBER;
  BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table INTO v_cnt;
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ' || v_cnt);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ? -> ' || SQLERRM);
  END;

  PROCEDURE try_p6(p_evt NUMBER) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('   Apel: raport_logistic_eveniment(' || p_evt || ')');
    raport_logistic_eveniment(p_evt);
    DBMS_OUTPUT.PUT_LINE('   -> OK (nu a aruncat exceptie ne-prinsa)');
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('   -> EROARE NEPRINSA: ' || SQLERRM);
  END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST P6: tabele goale =================');
  SAVEPOINT sp6;

  -- eveniment de test (ca sa putem apela in majoritatea subtestelor)
  BEGIN
    SELECT tip_eveniment INTO v_tip FROM Evenimente WHERE ROWNUM = 1;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    v_tip := 'TEST';
  END;

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, SYSDATE + 10, 10)
  RETURNING id_eveniment INTO v_evt_test;

  -- (A) EVENIMENTE gol
  DBMS_OUTPUT.PUT_LINE('--- (A) EVENIMENTE gol ---');
  SAVEPOINT tA;
  safe_exec('DELETE FROM Colaborari');
  safe_exec('DELETE FROM Evenimente_Produse');
  safe_exec('DELETE FROM Participari_evenimente');
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Evenimente');
  safe_count('Evenimente');
  try_p6(1);
  ROLLBACK TO tA;

  -- (B) PLANIFICARI_ORGANIZATORICE gol
  DBMS_OUTPUT.PUT_LINE('--- (B) PLANIFICARI_ORGANIZATORICE gol ---');
  SAVEPOINT tB;
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_count('Planificari_organizatorice');
  try_p6(v_evt_test);
  ROLLBACK TO tB;

  -- (C) SALI gol (sterge intai dependente uzuale)
  DBMS_OUTPUT.PUT_LINE('--- (C) SALI gol ---');
  SAVEPOINT tC;
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Rezervari'); -- ca sa poti goli SALI daca Rezervari refera SALI
  safe_exec('DELETE FROM Sali');
  safe_count('Sali');
  try_p6(v_evt_test);
  ROLLBACK TO tC;

  -- (D) PARTICIPARI_EVENIMENTE gol
  DBMS_OUTPUT.PUT_LINE('--- (D) PARTICIPARI_EVENIMENTE gol ---');
  SAVEPOINT tD;
  safe_exec('DELETE FROM Participari_evenimente');
  safe_count('Participari_evenimente');
  try_p6(v_evt_test);
  ROLLBACK TO tD;

  -- (E) EVENIMENTE_PRODUSE gol
  DBMS_OUTPUT.PUT_LINE('--- (E) EVENIMENTE_PRODUSE gol ---');
  SAVEPOINT tE;
  safe_exec('DELETE FROM Evenimente_Produse');
  safe_count('Evenimente_Produse');
  try_p6(v_evt_test);
  ROLLBACK TO tE;

  -- (F) PRODUSE gol (trebuie golit Evenimente_Produse intai) - daca e null
  DBMS_OUTPUT.PUT_LINE('--- (F) PRODUSE gol ---');
  SAVEPOINT tF;
  safe_exec('DELETE FROM Evenimente_Produse');
  safe_exec('DELETE FROM Liste_reduceri');
  safe_exec('DELETE FROM Comenzi_Produse');
  safe_exec('DELETE FROM Produse');
  safe_count('Produse');
  try_p6(v_evt_test);
  ROLLBACK TO tF;

  -- (G) ANGAJATI gol (trebuie golit Planificari_organizatorice intai)
  DBMS_OUTPUT.PUT_LINE('--- (G) ANGAJATI gol ---');
  SAVEPOINT tG;
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Comenzi_Angajati'); -- daca exista in schema ta
  safe_exec('DELETE FROM Angajati');
  safe_count('Angajati');
  try_p6(v_evt_test);
  ROLLBACK TO tG;

  ROLLBACK TO sp6;
  DBMS_OUTPUT.PUT_LINE('===========================================================');
END;
/








-- Exrcitiul 7







-- ============================================================
-- CERINTA 7 (Proiect SGBD 2025-2026)
-- Problema (limbaj natural):
--   Pentru o perioada data, afisam lista evenimentelor si, pentru fiecare eveniment,
--   salile alocate si numarul de angajati planificati in fiecare sala.
--   Se folosesc 2 tipuri de cursoare:
--     (1) cursor explicit cu OPEN/FETCH/CLOSE (pentru evenimente)
--     (2) cursor parametrizat, dependent de primul (pentru salile evenimentului),
--         parcurs cu cursor FOR loop.
-- ============================================================

SET SERVEROUTPUT ON;

CREATE OR REPLACE PROCEDURE raport_evenimente_sali(
    p_data_min IN DATE,
    p_data_max IN DATE
) AS
    -- Cursor 1: explicit (OPEN/FETCH/CLOSE)
    CURSOR c_evenimente IS
        SELECT id_eveniment, tip_eveniment, data_eveniment, numar_persoane
        FROM   Evenimente
        WHERE  data_eveniment BETWEEN p_data_min AND p_data_max
        ORDER  BY data_eveniment, id_eveniment;

    v_evt c_evenimente%ROWTYPE;
    v_gasit BOOLEAN := FALSE;

    -- Cursor 2: parametrizat (dependent de cursorul 1)
    CURSOR c_sali(p_id_eveniment NUMBER) IS
        SELECT s.id_sala,
               s.nume_sala,
               s.capacitate,
               COUNT(DISTINCT po.id_angajat) AS nr_angajati
        FROM   Planificari_organizatorice po
               JOIN Sali s ON s.id_sala = po.id_sala
        WHERE  po.id_eveniment = p_id_eveniment
        GROUP  BY s.id_sala, s.nume_sala, s.capacitate
        ORDER  BY s.nume_sala;

    v_participanti NUMBER;
    v_cap_total    NUMBER;
    v_are_sali     BOOLEAN;
BEGIN
    DBMS_OUTPUT.PUT_LINE('============================================================');
    DBMS_OUTPUT.PUT_LINE('RAPORT EVENIMENTE -> SALI + ANGAJATI');
    DBMS_OUTPUT.PUT_LINE('Perioada: ' || TO_CHAR(p_data_min,'YYYY-MM-DD') || ' .. ' || TO_CHAR(p_data_max,'YYYY-MM-DD'));
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');

    OPEN c_evenimente;
    LOOP
        FETCH c_evenimente INTO v_evt;
        EXIT WHEN c_evenimente%NOTFOUND;

        v_gasit := TRUE;

        -- participanti inscrisi (0 daca nu exista)
        SELECT COUNT(*)
        INTO   v_participanti
        FROM   Participari_evenimente
        WHERE  id_eveniment = v_evt.id_eveniment;

        DBMS_OUTPUT.PUT_LINE('Eveniment #' || v_evt.id_eveniment ||
                             ' | ' || v_evt.tip_eveniment ||
                             ' | ' || TO_CHAR(v_evt.data_eveniment,'YYYY-MM-DD') ||
                             ' | persoane=' || v_evt.numar_persoane ||
                             ' | participanti=' || v_participanti);

        DBMS_OUTPUT.PUT_LINE('  Sali alocate:');

        v_cap_total := 0;
        v_are_sali  := FALSE;

        -- Cursor parametrizat dependent de evenimentul curent
        FOR r IN c_sali(v_evt.id_eveniment) LOOP
            v_are_sali  := TRUE;
            v_cap_total := v_cap_total + r.capacitate;

            DBMS_OUTPUT.PUT_LINE('   - ' || RPAD(r.nume_sala, 18) ||
                                 ' (cap=' || r.capacitate || ')' ||
                                 ' | angajati_planificati=' || r.nr_angajati);
        END LOOP;

        IF NOT v_are_sali THEN
            DBMS_OUTPUT.PUT_LINE('   (nu exista sali planificate pentru acest eveniment)');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  Capacitate totala sali: ' || v_cap_total);

            IF v_evt.numar_persoane > v_cap_total THEN
                DBMS_OUTPUT.PUT_LINE('  ATENTIE: capacitate insuficienta pentru numarul de persoane!');
            END IF;
        END IF;

        DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');
    END LOOP;
    CLOSE c_evenimente;

    IF NOT v_gasit THEN
        DBMS_OUTPUT.PUT_LINE('Nu exista evenimente in perioada selectata.');
    END IF;

    DBMS_OUTPUT.PUT_LINE('============================================================');
END;
/
SHOW ERRORS;

-- ============================================================
-- APEL (exemplu)
-- ============================================================
BEGIN
    raport_evenimente_sali(DATE '1900-01-01', DATE '2999-12-31');
END;
/


INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (5, 1, 2, 'servire sala mare');
INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (4, 1, 2, 'servire sala mare');
COMMIT;

-- DELETE FROM PLANIFICARI_ORGANIZATORICE po
-- WHERE po.ID_EVENIMENT = 1 AND (po.ID_ANGAJAT = 5 OR po.ID_ANGAJAT = 4);

SET SERVEROUTPUT ON;

DECLARE
  v_evt   NUMBER;
  v_sala  NUMBER;
  v_ang   NUMBER;
  v_mail  VARCHAR2(200);
BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST PUNCTUL 7 =================');
  SAVEPOINT sp7;

  -- Caz 1: perioada fara evenimente (mesajul "Nu exista evenimente...")
  DBMS_OUTPUT.PUT_LINE('--- Caz 1: perioada fara evenimente ---');
  raport_evenimente_sali(DATE '1800-01-01', DATE '1800-12-31');
  raport_evenimente_sali(NULL, NULL);

  -- Caz 2: perioada cu evenimente (datele existente)
  DBMS_OUTPUT.PUT_LINE('--- Caz 2: perioada cu evenimente ---');
  raport_evenimente_sali(DATE '1900-01-01', DATE '2999-12-31');

  -- Caz 3: avertizare "capacitate insuficienta"
  DBMS_OUTPUT.PUT_LINE('--- Caz 3: capacitate insuficienta (eveniment de test) ---');

  INSERT INTO Sali (nume_sala, capacitate)
  VALUES ('SALA_TEST_P7', 5)
  RETURNING id_sala INTO v_sala;

  v_mail := 'p7_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com';
  INSERT INTO Angajati (nume, prenume, functie, salariu, mail)
  VALUES ('Test', 'P7', 'Chelner', 3000, v_mail)
  RETURNING id_angajat INTO v_ang;

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST_P7', DATE '2099-02-01', 50)
  RETURNING id_eveniment INTO v_evt;

  INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii)
  VALUES (v_ang, v_evt, v_sala, 'test capacitate');

  raport_evenimente_sali(DATE '2099-02-01', DATE '2099-02-01');

  ROLLBACK TO sp7;
  DBMS_OUTPUT.PUT_LINE('===================================================');
END;
/


SET SERVEROUTPUT ON;

DECLARE
  PROCEDURE safe_exec(p_sql VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE p_sql;
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   [WARN] ' || p_sql || ' -> ' || SQLERRM);
  END;

  PROCEDURE safe_count(p_table VARCHAR2) IS
    v_cnt NUMBER;
  BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table INTO v_cnt;
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ' || v_cnt);
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ? -> ' || SQLERRM);
  END;

  PROCEDURE try_p7 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('   Apel: raport_evenimente_sali(1900-01-01, 2999-12-31)');
    raport_evenimente_sali(DATE '1900-01-01', DATE '2999-12-31');
    DBMS_OUTPUT.PUT_LINE('   -> OK (nu a aruncat exceptie ne-prinsa)');
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   -> EROARE NEPRINSA: ' || SQLERRM);
  END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST P7: tabele goale =================');
  SAVEPOINT sp7;

  -- (A) EVENIMENTE gol (stergem dependente uzuale)
  DBMS_OUTPUT.PUT_LINE('--- (A) EVENIMENTE gol ---');
  SAVEPOINT tA;
  safe_exec('DELETE FROM Participari_evenimente');
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Colaborari');
  safe_exec('DELETE FROM Evenimente_produse');
  safe_exec('DELETE FROM Evenimente');
  safe_count('Evenimente');
  try_p7;
  ROLLBACK TO tA;

  -- (B) PARTICIPARI_EVENIMENTE gol
  DBMS_OUTPUT.PUT_LINE('--- (B) PARTICIPARI_EVENIMENTE gol ---');
  SAVEPOINT tB;
  safe_exec('DELETE FROM Participari_evenimente');
  safe_count('Participari_evenimente');
  try_p7;
  ROLLBACK TO tB;

  -- (C) PLANIFICARI_ORGANIZATORICE gol
  DBMS_OUTPUT.PUT_LINE('--- (C) PLANIFICARI_ORGANIZATORICE gol ---');
  SAVEPOINT tC;
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_count('Planificari_organizatorice');
  try_p7;
  ROLLBACK TO tC;

  -- (D) SALI gol (necesita sa golesti tabele care refera SALI)
  DBMS_OUTPUT.PUT_LINE('--- (D) SALI gol ---');
  SAVEPOINT tD;
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Rezervari'); -- daca Rezervari refera SALI
  safe_exec('DELETE FROM Sali');
  safe_count('Sali');
  try_p7;
  ROLLBACK TO tD;

  ROLLBACK TO sp7;
  DBMS_OUTPUT.PUT_LINE('===========================================================');
END;
/







-- Exercitiul 8







-- ============================================================
-- PUNCTUL 8 (Proiect SGBD 2025-2026)

-- Problema (limbaj natural):
--   "Pentru un client si o zi data, determina sala (si detalii despre rezervare)
--    in care clientul are rezervare. Daca nu exista rezervare -> NO_DATA_FOUND.
--    Daca exista mai multe rezervari in aceeasi zi pentru acel client -> TOO_MANY_ROWS."
--
-- Tabele folosite in comanda SQL (exact 3):
--   CLIENTI, REZERVARI, SALI
-- ============================================================

SET SERVEROUTPUT ON;

-- optional curatare
BEGIN
  EXECUTE IMMEDIATE 'DROP FUNCTION f_detalii_rezervare_client_zi';
EXCEPTION
  WHEN OTHERS THEN NULL;
END;
/
SHOW ERRORS;

CREATE OR REPLACE FUNCTION f_detalii_rezervare_client_zi(
    p_id_client IN NUMBER,
    p_data      IN DATE
) RETURN VARCHAR2
AS
    -- exceptie proprie pentru parametri invalizi
    e_param_invalizi EXCEPTION;

    v_rezultat VARCHAR2(4000);
BEGIN
    IF p_id_client IS NULL OR p_data IS NULL OR p_id_client <> TRUNC(p_id_client) THEN
        RAISE e_param_invalizi;
    END IF;

    -- O singura comanda SQL care foloseste 3 tabele: Clienti, Rezervari, Sali
    SELECT
        'Client: ' || c.nume || ' ' || c.prenume ||
        ' | Sala: '  || s.nume_sala ||
        ' | Data: '  || TO_CHAR(r.data_rezervare, 'YYYY-MM-DD') ||
        ' | Ora: '   || r.ora_rezervare ||
        ' | Persoane: ' || r.numar_persoane
    INTO v_rezultat
    FROM Clienti c
    JOIN Rezervari r ON r.id_client = c.id_client
    JOIN Sali s      ON s.id_sala   = r.id_sala
    WHERE c.id_client = p_id_client
      AND TRUNC(r.data_rezervare) = TRUNC(p_data);

    RETURN v_rezultat;

EXCEPTION
    WHEN e_param_invalizi THEN
        DBMS_OUTPUT.PUT_LINE('[PARAMETRI INVALIZI] id_client sau data nu sunt corecte.');
        RETURN 'PARAMETRI INVALIZI';

    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('[NO_DATA_FOUND] Nu exista rezervare pentru clientul ' || p_id_client ||
                             ' la data ' || TO_CHAR(p_data, 'YYYY-MM-DD') || '.');
        RETURN 'NU EXISTA REZERVARE';

    WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('[TOO_MANY_ROWS] Exista mai multe rezervari pentru clientul ' || p_id_client ||
                             ' la data ' || TO_CHAR(p_data, 'YYYY-MM-DD') || '.');
        DBMS_OUTPUT.PUT_LINE('Lista rezervarilor din acea zi:');

        FOR rr IN (
            SELECT r.id_rezervare,
                   TO_CHAR(r.data_rezervare, 'YYYY-MM-DD') AS data_rez,
                   r.ora_rezervare,
                   r.numar_persoane,
                   s.nume_sala
            FROM Rezervari r
            JOIN Sali s ON s.id_sala = r.id_sala
            WHERE r.id_client = p_id_client
              AND TRUNC(r.data_rezervare) = TRUNC(p_data)
            ORDER BY r.ora_rezervare, r.id_rezervare
        ) LOOP
            DBMS_OUTPUT.PUT_LINE(' - Rez#' || rr.id_rezervare ||
                                 ' | ' || rr.data_rez ||
                                 ' ' || rr.ora_rezervare ||
                                 ' | sala=' || rr.nume_sala ||
                                 ' | persoane=' || rr.numar_persoane);
        END LOOP;

        RETURN 'PREA MULTE REZERVARI';

    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('[ALTA EROARE] ' || SQLERRM);
        RETURN 'EROARE: ' || SQLERRM;
END;
/
SHOW ERRORS;

-- ============================================================
-- APELURI DE TEST
-- ============================================================
DECLARE
    v_client_id NUMBER := 1;  -- presupunere standard in setul de date 7/12 (ID-uri identity de la 1)
    v_sala_id   NUMBER := 1;
    v_data_ok   DATE   := DATE '2099-12-30';
BEGIN
    DBMS_OUTPUT.PUT_LINE('================ TEST PUNCTUL 8 ================');

    -- Folosim SAVEPOINT ca sa nu "murdarim" baza de date dupa demonstratie
    SAVEPOINT sp_test_8;

    -- 1) Caz NORMAL: exact o rezervare in acea zi
    INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala)
    VALUES (v_data_ok, '12:00', 4, v_client_id, v_sala_id);

    DBMS_OUTPUT.PUT_LINE('--- Caz normal (1 rand) ---');
    DBMS_OUTPUT.PUT_LINE(f_detalii_rezervare_client_zi(v_client_id, v_data_ok));

    -- 2) Caz NO_DATA_FOUND: zi fara rezervare
    DBMS_OUTPUT.PUT_LINE('--- Caz NO_DATA_FOUND ---');
    DBMS_OUTPUT.PUT_LINE(f_detalii_rezervare_client_zi(v_client_id, DATE '2099-12-29'));
    DBMS_OUTPUT.PUT_LINE(f_detalii_rezervare_client_zi(v_client_id, NULL));

    -- 3) Caz TOO_MANY_ROWS: introducem a doua rezervare in aceeasi zi pentru acelasi client
    INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala)
    VALUES (v_data_ok, '14:00', 2, v_client_id, v_sala_id);

    DBMS_OUTPUT.PUT_LINE('--- Caz TOO_MANY_ROWS ---');
    DBMS_OUTPUT.PUT_LINE(f_detalii_rezervare_client_zi(v_client_id, v_data_ok));

    -- 4) Caz parametri invalizi (exceptie proprie)
    DBMS_OUTPUT.PUT_LINE('--- Caz parametri invalizi ---');
    DBMS_OUTPUT.PUT_LINE(f_detalii_rezervare_client_zi(v_client_id, NULL));

    DBMS_OUTPUT.PUT_LINE('--- Caz parametri invalizi 2---');
    DBMS_OUTPUT.PUT_LINE(f_detalii_rezervare_client_zi(1.5, DATE '2099-12-29'));

    -- revenim la starea initiala
    ROLLBACK TO sp_test_8;

    DBMS_OUTPUT.PUT_LINE('================================================');
END;
/

-- SET SERVEROUTPUT ON;

DECLARE
  v_ret VARCHAR2(4000);

  PROCEDURE safe_exec(p_sql VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE p_sql;
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   [WARN] ' || p_sql || ' -> ' || SQLERRM);
  END;

  PROCEDURE safe_count(p_table VARCHAR2) IS
    v_cnt NUMBER;
  BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table INTO v_cnt;
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ' || v_cnt);
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ? -> ' || SQLERRM);
  END;

  PROCEDURE try_p8 IS
  BEGIN
    v_ret := f_detalii_rezervare_client_zi(1, DATE '2099-01-01');
    DBMS_OUTPUT.PUT_LINE('   Return: ' || v_ret);
    DBMS_OUTPUT.PUT_LINE('   -> OK (nu a aruncat exceptie ne-prinsa)');
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   -> EROARE NEPRINSA: ' || SQLERRM);
  END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST P8: tabele goale =================');
  SAVEPOINT sp8;

  -- (A) CLIENTI gol (stergem intai Rezervari)
  DBMS_OUTPUT.PUT_LINE('--- (A) CLIENTI gol ---');
  SAVEPOINT tA;
  safe_exec('DELETE FROM Rezervari');
  safe_exec('DELETE FROM Participari_evenimente');
  safe_exec('DELETE FROM Comenzi_produse');
  safe_exec('DELETE FROM Comenzi_angajati');
  safe_exec('DELETE FROM Comenzi');
  safe_exec('DELETE FROM Clienti');
  safe_count('Clienti');
  try_p8;
  ROLLBACK TO tA;

  -- (B) REZERVARI gol
  DBMS_OUTPUT.PUT_LINE('--- (B) REZERVARI gol ---');
  SAVEPOINT tB;
  safe_exec('DELETE FROM Rezervari');
  safe_count('Rezervari');
  try_p8;
  ROLLBACK TO tB;

  -- (C) SALI gol (necesita sa golesti tabele care refera SALI)
  DBMS_OUTPUT.PUT_LINE('--- (C) SALI gol ---');
  SAVEPOINT tC;
  safe_exec('DELETE FROM Rezervari');
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Sali');
  safe_count('Sali');
  try_p8;
  ROLLBACK TO tC;

  ROLLBACK TO sp8;
  DBMS_OUTPUT.PUT_LINE('===========================================================');
END;
/

ROLLBACK;
/









-- Exercitiul 9










-- ============================================================
-- PUNCTUL 9 (Proiect SGBD 2025-2026) - Procedura stocata independenta

-- Problema (limbaj natural):
--  "Pentru un client dat, afiseaza ultimele N evenimente la care a participat
--   (N = p_max_evenimente: 1 -> ultimul, 2 -> ultimele doua, etc.).
--   Pentru fiecare eveniment, afiseaza raportul de participare:
--   detalii eveniment, total participanti inscrisi, angajati planificati,
--   sali alocate, capacitate totala,
--   ceilalti participanti inregistrati."
-- ============================================================

SET SERVEROUTPUT ON;

BEGIN
  EXECUTE IMMEDIATE 'DROP PROCEDURE p9_raport_istoric_client';
EXCEPTION
  WHEN OTHERS THEN NULL;
END;
/
SHOW ERRORS;

CREATE OR REPLACE PROCEDURE p9_raport_istoric_client(
    p_id_client      IN NUMBER,
    p_max_evenimente IN NUMBER
)
AS
    -- Exceptii proprii (minim 2)
    e_parametri_invalizi EXCEPTION;
    e_fara_evenimente    EXCEPTION;

    v_nume_client   VARCHAR2(200);
    v_afisate       PLS_INTEGER := 0;

    -- Cursor = O singura comanda SQL care foloseste 5 tabele distincte:
    --   Clienti, Evenimente, Participari_evenimente, Planificari_organizatorice, Sali
    CURSOR c_raport(p_cid NUMBER, p_lim NUMBER) IS
      SELECT *
      FROM (
        SELECT
          e.id_eveniment,
          e.tip_eveniment,
          e.data_eveniment,
          e.numar_persoane,
          c.nume || ' ' || c.prenume AS nume_client,

          COUNT(DISTINCT pe_all.id_client) AS total_participanti_inregistrati,
          COUNT(DISTINCT po.id_angajat)    AS angajati_planificati,
          COUNT(DISTINCT po.id_sala)       AS nr_sali,

          -- capacitate totala (sum pe sali distincte) via subquery
          NVL((
              SELECT SUM(s2.capacitate)
              FROM Sali s2
              WHERE s2.id_sala IN (
                SELECT DISTINCT po2.id_sala
                FROM Planificari_organizatorice po2
                WHERE po2.id_eveniment = e.id_eveniment
              )
          ), 0) AS capacitate_totala,

          ROW_NUMBER() OVER (ORDER BY e.data_eveniment DESC, e.id_eveniment DESC) AS rn
        FROM Evenimente e
        JOIN Clienti c
          ON c.id_client = p_cid
        LEFT JOIN Participari_evenimente pe_all
          ON pe_all.id_eveniment = e.id_eveniment
        LEFT JOIN Planificari_organizatorice po
          ON po.id_eveniment = e.id_eveniment
        WHERE EXISTS (
          SELECT 1
          FROM Participari_evenimente pe
          WHERE pe.id_eveniment = e.id_eveniment
            AND pe.id_client = p_cid
        )
        GROUP BY
          e.id_eveniment, e.tip_eveniment, e.data_eveniment, e.numar_persoane,
          c.nume, c.prenume
      )
      WHERE rn <= p_lim
      ORDER BY data_eveniment DESC, id_eveniment DESC;

BEGIN
    -- 0) Validare parametri
    IF p_id_client IS NULL OR p_max_evenimente IS NULL OR p_max_evenimente < 1 OR p_id_client <> TRUNC(p_id_client) OR p_max_evenimente <> TRUNC(p_max_evenimente) THEN
      RAISE e_parametri_invalizi;
    END IF;

    -- 1) Preluam numele clientului (poate arunca NO_DATA_FOUND)
    SELECT nume || ' ' || prenume
    INTO   v_nume_client
    FROM   Clienti
    WHERE  id_client = p_id_client;

    DBMS_OUTPUT.PUT_LINE('============================================================');
    DBMS_OUTPUT.PUT_LINE('ISTORIC EVENIMENTE CLIENT (P9)');
    DBMS_OUTPUT.PUT_LINE('Client #' || p_id_client || ': ' || v_nume_client);
    DBMS_OUTPUT.PUT_LINE('Ultimele N evenimente (N=' || p_max_evenimente || '), incepand cu cel mai recent.');
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');

    -- 2) Afisam raportul pentru fiecare eveniment selectat
    FOR r IN c_raport(p_id_client, p_max_evenimente) LOOP
      v_afisate := v_afisate + 1;
    
      DBMS_OUTPUT.PUT_LINE('Eveniment #' || r.id_eveniment ||
                             ' | ' || r.tip_eveniment ||
                             ' | Data: ' || TO_CHAR(r.data_eveniment, 'YYYY-MM-DD') ||
                             ' | Persoane(plan): ' || r.numar_persoane);

      DBMS_OUTPUT.PUT_LINE('  Participanti inscrisi: ' || r.total_participanti_inregistrati ||
                             ' | Angajati planificati: ' || r.angajati_planificati);

      DBMS_OUTPUT.PUT_LINE('  Sali: ' || r.nr_sali ||
                             ' | Capacitate totala: ' || r.capacitate_totala);

      -- Lista altor clienti inscrisi la eveniment (cu colectie + exceptii specifice colectiilor)
      DECLARE
        TYPE t_alti_clienti_nt IS TABLE OF VARCHAR2(200); -- NESTED TABLE (PL/SQL)
        v_alti_clienti t_alti_clienti_nt;                 -- va fi populata prin BULK COLLECT
      BEGIN
        SELECT 'Client #' || c2.id_client || ': ' || c2.nume || ' ' || c2.prenume
        BULK COLLECT INTO v_alti_clienti
        FROM   Participari_evenimente pe2
        JOIN   Clienti c2 ON c2.id_client = pe2.id_client
        WHERE  pe2.id_eveniment = r.id_eveniment
          AND  pe2.id_client <> p_id_client
        ORDER BY c2.id_client;
      
        -- Afisare: incercam sa afisam primul element; daca nu exista -> SUBSCRIPT_BEYOND_COUNT
        BEGIN
          DBMS_OUTPUT.PUT_LINE('  Alti clienti inregistrati:');
          DBMS_OUTPUT.PUT_LINE('    - ' || v_alti_clienti(1)); -- daca lista e goala -> exceptie
      
          IF v_alti_clienti.COUNT > 1 THEN
            FOR i IN 2 .. v_alti_clienti.COUNT LOOP
              DBMS_OUTPUT.PUT_LINE('    - ' || v_alti_clienti(i));
            END LOOP;
          END IF;
      
          DBMS_OUTPUT.PUT_LINE('    (Total alti clienti: ' || v_alti_clienti.COUNT || ')');
      
        EXCEPTION
          WHEN SUBSCRIPT_BEYOND_COUNT THEN
            DBMS_OUTPUT.PUT_LINE('  Alti clienti inregistrati: (niciunul) -> clientul este singurul inregistrat.');
      
          WHEN COLLECTION_IS_NULL THEN
            DBMS_OUTPUT.PUT_LINE('  [EROARE COLECTIE] Colectia este NULL (COLLECTION_IS_NULL).');
      
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('  [EROARE COLECTIE] ' || SQLERRM);
        END;
      END;
      
      DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');

    END LOOP;

    -- 3) Daca nu exista evenimente pentru client
    IF v_afisate = 0 THEN
      RAISE e_fara_evenimente;
    END IF;

    DBMS_OUTPUT.PUT_LINE('Total evenimente afisate: ' || v_afisate);
    DBMS_OUTPUT.PUT_LINE('============================================================');

EXCEPTION
    WHEN e_parametri_invalizi THEN
      DBMS_OUTPUT.PUT_LINE('[P9] PARAMETRI INVALIDI: p_id_client si p_max_evenimente trebuie sa fie nenule, iar p_max_evenimente >=1 si ambele sunt numere intregi.');

    WHEN e_fara_evenimente THEN
      DBMS_OUTPUT.PUT_LINE('[P9] NU EXISTA EVENIMENTE: clientul #' || p_id_client ||
                           ' nu are participari inregistrate.');

    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE('[P9] NO_DATA_FOUND: nu exista client cu id_client=' || p_id_client);

    WHEN TOO_MANY_ROWS THEN
      DBMS_OUTPUT.PUT_LINE('[P9] TOO_MANY_ROWS: o interogare SELECT INTO a returnat mai multe randuri.');

    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('[P9] ALTA EROARE: ' || SQLERRM);
END;
/
SHOW ERRORS;

-- ============================================================
-- TESTARE
-- ============================================================
DECLARE
  v_client_ok     NUMBER;
  v_client_fara   NUMBER;

  v_tip_existent Evenimente.tip_eveniment%TYPE;

  v_evt_singur  NUMBER;  -- id_eveniment pentru cazul clientul e singurul
  v_evt_multi   NUMBER;  -- id_eveniment pentru cazul mai multi alti clienti
  v_c2          NUMBER;  -- id_client pentru primul client extra
  v_c3          NUMBER;  -- id_client pentru al doilea client extra


BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST PUNCTUL 9 =================');
  SAVEPOINT sp9;

  -- A) Alegem un client existent (sau cream unul daca tabela e goala)
  BEGIN
    SELECT MIN(id_client) INTO v_client_ok FROM Clienti;
    IF v_client_ok IS NULL THEN
      INSERT INTO Clienti (nume, prenume, nr_tel, mail)
      VALUES ('Client', 'Default', '0712345678',
              'p9_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com')
      RETURNING id_client INTO v_client_ok;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      INSERT INTO Clienti (nume, prenume, nr_tel, mail)
      VALUES ('Client', 'Default', '0712345678',
              'p9_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com')
      RETURNING id_client INTO v_client_ok;
  END;

  -- Tip eveniment existent (ca sa treaca orice CHECK posibil)
  BEGIN
    SELECT tip_eveniment INTO v_tip_existent FROM Evenimente WHERE ROWNUM = 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_tip_existent := 'TEST';
  END;

  -- 1) Parametri invalizi (exceptie proprie)
  DBMS_OUTPUT.PUT_LINE('--- Caz 1: parametri invalizi ---');
  p9_raport_istoric_client(v_client_ok, 0);

  DBMS_OUTPUT.PUT_LINE('--- Caz 1: parametri invalizi 2---');
  p9_raport_istoric_client(v_client_ok, 1.5);

  -- 2) Client inexistent (NO_DATA_FOUND)
  DBMS_OUTPUT.PUT_LINE('--- Caz 2: client inexistent ---');
  p9_raport_istoric_client(-999999, 1);

  -- 3) Client fara participari (exceptie proprie)
  DBMS_OUTPUT.PUT_LINE('--- Caz 3: client fara participari ---');
  INSERT INTO Clienti (nume, prenume, nr_tel, mail)
  VALUES ('Client', 'FaraParticipari', '0799999999',
          'p9_nop_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com')
  RETURNING id_client INTO v_client_fara;

  p9_raport_istoric_client(v_client_fara, 2);

  -- 4) Eveniment unde clientul e singurul inregistrat (SUBSCRIPT_BEYOND_COUNT pe colectie)
  DBMS_OUTPUT.PUT_LINE('--- Caz 4: singurul client (lista alti clienti vida -> SUBSCRIPT_BEYOND_COUNT) ---');
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip_existent, DATE '2099-12-30', 10)
  RETURNING id_eveniment INTO v_evt_singur;
  
  INSERT INTO Participari_evenimente (id_eveniment, id_client)
  VALUES (v_evt_singur, v_client_ok);
  
  p9_raport_istoric_client(v_client_ok, 1);
  
  -- 5) Eveniment cu mai multi alti clienti (colectia are elemente -> listare)
  DBMS_OUTPUT.PUT_LINE('--- Caz 5: mai multi clienti (colectia are elemente -> listare completa) ---');
  
  INSERT INTO Clienti (nume, prenume, nr_tel, mail)
  VALUES ('Client', 'Extra1', '0711111111',
          'p9_c2_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com')
  RETURNING id_client INTO v_c2;
  
  INSERT INTO Clienti (nume, prenume, nr_tel, mail)
  VALUES ('Client', 'Extra2', '0722222222',
          'p9_c3_' || TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3') || '@ex.com')
  RETURNING id_client INTO v_c3;
  
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip_existent, DATE '2100-01-01', 20)
  RETURNING id_eveniment INTO v_evt_multi;
  
  INSERT INTO Participari_evenimente (id_eveniment, id_client)
  VALUES (v_evt_multi, v_client_ok);
  
  INSERT INTO Participari_evenimente (id_eveniment, id_client)
  VALUES (v_evt_multi, v_c2);
  
  INSERT INTO Participari_evenimente (id_eveniment, id_client)
  VALUES (v_evt_multi, v_c3);
  
  p9_raport_istoric_client(v_client_ok, 1);
  
  ROLLBACK TO sp9;
  DBMS_OUTPUT.PUT_LINE('===================================================');
END;
/

-- SET SERVEROUTPUT ON;

DECLARE
  PROCEDURE safe_exec(p_sql VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE p_sql;
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   [WARN] ' || p_sql || ' -> ' || SQLERRM);
  END;

  PROCEDURE safe_count(p_table VARCHAR2) IS
    v_cnt NUMBER;
  BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table INTO v_cnt;
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ' || v_cnt);
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   COUNT(' || p_table || ') = ? -> ' || SQLERRM);
  END;

  PROCEDURE try_p9 IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('   Apel: p9_raport_istoric_client(1, 2)');
    p9_raport_istoric_client(1, 2);
    DBMS_OUTPUT.PUT_LINE('   -> OK (nu a aruncat exceptie ne-prinsa)');
  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('   -> EROARE NEPRINSA: ' || SQLERRM);
  END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST P9: tabele goale =================');
  SAVEPOINT sp9;

  -- (A) CLIENTI gol (stergem dependente uzuale)
  DBMS_OUTPUT.PUT_LINE('--- (A) CLIENTI gol ---');
  SAVEPOINT tA;
  safe_exec('DELETE FROM Rezervari');
  safe_exec('DELETE FROM Participari_evenimente');
  safe_exec('DELETE FROM Comenzi_produse');
  safe_exec('DELETE FROM Comenzi_angajati');
  safe_exec('DELETE FROM Comenzi');
  safe_exec('DELETE FROM Clienti');
  safe_count('Clienti');
  try_p9;
  ROLLBACK TO tA;

  -- (B) EVENIMENTE gol
  DBMS_OUTPUT.PUT_LINE('--- (B) EVENIMENTE gol ---');
  SAVEPOINT tB;
  safe_exec('DELETE FROM Participari_evenimente');
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Colaborari');
  safe_exec('DELETE FROM Evenimente_produse');
  safe_exec('DELETE FROM Evenimente');
  safe_count('Evenimente');
  try_p9;
  ROLLBACK TO tB;

  -- (C) PARTICIPARI_EVENIMENTE gol
  DBMS_OUTPUT.PUT_LINE('--- (C) PARTICIPARI_EVENIMENTE gol ---');
  SAVEPOINT tC;
  safe_exec('DELETE FROM Participari_evenimente');
  safe_count('Participari_evenimente');
  try_p9;
  ROLLBACK TO tC;

  -- (D) PLANIFICARI_ORGANIZATORICE gol
  DBMS_OUTPUT.PUT_LINE('--- (D) PLANIFICARI_ORGANIZATORICE gol ---');
  SAVEPOINT tD;
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_count('Planificari_organizatorice');
  try_p9;
  ROLLBACK TO tD;

  -- (E) SALI gol (necesita sa golesti tabele care refera SALI)
  DBMS_OUTPUT.PUT_LINE('--- (E) SALI gol ---');
  SAVEPOINT tE;
  safe_exec('DELETE FROM Rezervari');
  safe_exec('DELETE FROM Planificari_organizatorice');
  safe_exec('DELETE FROM Sali');
  safe_count('Sali');
  try_p9;
  ROLLBACK TO tE;

  ROLLBACK TO sp9;
  DBMS_OUTPUT.PUT_LINE('===========================================================');
END;
/

ROLLBACK;
/








-- Exercitiile 10, 11, 12 : implementare + testare






-- ============================================================
-- Triggere pentru cerintele 10, 11, 12
--
-- 10) Trigger LMD la nivel de comanda (statement-level)
--     Valideaza programarile din PLANIFICARI_ORGANIZATORICE.
--
-- 11) Trigger LMD la nivel de linie (row-level)
--     Blocheaza rezervarile intr-o sala in care exista eveniment in aceeasi zi.
--
-- 12) Exemplu Trigger LDD (DDL)
--     Audit pentru CREATE/ALTER/DROP la nivel de schema + blocare actiuni pe entitati protejate.
-- ============================================================

-- ============================================================
-- 10) TRIGGER LMD - nivel de comanda (STATEMENT-LEVEL)
-- ============================================================
-- Idee business:
  -- - Dupa orice INSERT/UPDATE/DELETE in PLANIFICARI_ORGANIZATORICE, se verifica:
  --     (1) Nu exista sala cu 2 evenimente diferite in aceeasi zi.
  --     (2) Nu exista sala in care, in aceeasi zi, exista si eveniment si rezervare.
  -- - Daca apare conflict, se respinge comanda si se afiseaza un mesaj util.
  -- - Daca, pentru data conflictului, nu mai exista nicio sala libera (toate sunt ocupate
  --   prin evenimente sau rezervari), mesajul cere mutarea datei evenimentului.

-- INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane) VALUES ('botez', DATE '2026-02-14', 150);
-- COMMIT;
-- INSERT INTO Planificari_organizatorice (id_angajat, id_eveniment, id_sala, observatii) VALUES (2, 1, 1, 'servire sala mare');
-- COMMIT;



-- 10.)

BEGIN
  EXECUTE IMMEDIATE 'DROP TRIGGER trg_po_conflicte_stmt';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
CREATE OR REPLACE TRIGGER trg_po_conflicte_stmt
AFTER INSERT OR UPDATE ON Planificari_organizatorice
DECLARE
  v_sala NUMBER;
  v_data DATE;
BEGIN
  -- 1) Conflict: aceeasi sala + aceeasi zi -> 2+ evenimente diferite
  BEGIN
    SELECT x.id_sala, x.d
    INTO   v_sala, v_data
    FROM (
      SELECT po.id_sala AS id_sala,
             TRUNC(e.data_eveniment) AS d
      FROM   Planificari_organizatorice po
      JOIN   Evenimente e ON e.id_eveniment = po.id_eveniment
      GROUP  BY po.id_sala, TRUNC(e.data_eveniment)
      HAVING COUNT(DISTINCT po.id_eveniment) > 1
    ) x
    WHERE ROWNUM = 1;

    RAISE_APPLICATION_ERROR(
      -20010,
      'Planificare respinsa: sala ' || v_sala ||
      ' este alocata la mai multe evenimente in data ' || TO_CHAR(v_data,'YYYY-MM-DD') ||
      '. Alege alta sala sau muta data.'
    );
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      NULL;
  END;

  -- 2) Conflict: exista rezervari in aceeasi sala + aceeasi zi cu un eveniment planificat
  BEGIN
    SELECT x.id_sala, x.d
    INTO   v_sala, v_data
    FROM (
      SELECT DISTINCT po.id_sala AS id_sala,
             TRUNC(e.data_eveniment) AS d
      FROM   Planificari_organizatorice po
      JOIN   Evenimente e ON e.id_eveniment = po.id_eveniment
      WHERE  EXISTS (
        SELECT 1
        FROM   Rezervari r
        WHERE  r.id_sala = po.id_sala
          AND  TRUNC(r.data_rezervare) = TRUNC(e.data_eveniment)
      )
    ) x
    WHERE ROWNUM = 1;

    RAISE_APPLICATION_ERROR(
      -20011,
      'Planificare respinsa: exista rezervari in sala ' || v_sala ||
      ' la data ' || TO_CHAR(v_data,'YYYY-MM-DD') ||
      '. Reprogrameaza rezervarile sau muta data evenimentului.'
    );
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      NULL;
  END;

END;
/




-- ============================================================
-- 11) TRIGGER LMD - nivel de linie (ROW-LEVEL)
-- ============================================================
-- Idee business:
--   - Pentru fiecare rezervare inserata/modificata, se verifica daca in sala aleasa
--     exista un eveniment programat in aceeasi zi.
--   - Daca exista, se respinge rezervarea.
--   - Se verifica si capacitatea salii.

BEGIN
  EXECUTE IMMEDIATE 'DROP TRIGGER trg_rezervari_capacitate';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_rezervari_capacitate
BEFORE INSERT OR UPDATE ON Rezervari
FOR EACH ROW
DECLARE
  v_dummy NUMBER;
BEGIN
  --  Sala exista?
  BEGIN
    SELECT 1 INTO v_dummy
    FROM Sali
    WHERE id_sala = :NEW.id_sala;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20020, 'Sala inexistent (id_sala='||:NEW.id_sala||').');
  END;

  -- Exista eveniment in aceeasi sala + aceeasi zi?
  BEGIN
    SELECT 1 INTO v_dummy
    FROM dual
    WHERE EXISTS (
      SELECT 1
      FROM Planificari_organizatorice po
      JOIN Evenimente e
        ON e.id_eveniment = po.id_eveniment
      WHERE po.id_sala = :NEW.id_sala
        AND TRUNC(e.data_eveniment) = TRUNC(:NEW.data_rezervare)
    );

    -- daca EXISTS a gasit ceva => respingem
    RAISE_APPLICATION_ERROR(
      -20021,
      'Rezervare respinsa: exista eveniment in sala '||:NEW.id_sala||
      ' la data '||TO_CHAR(:NEW.data_rezervare,'YYYY-MM-DD')||'.'
    );
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      NULL; -- nu exista eveniment
  END;

END;
/




-- ============================================================
-- 12) EXEMPLU TRIGGER LDD (DDL) - audit DDL la nivel de schema + blocare pe entitati
-- ============================================================


-- ALTER TRIGGER trg_audit_ddl DISABLE;
-- DROP TABLE audit_ddl;
-- DROP TABLE guard_ldd;

CREATE TABLE audit_ddl (
  id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_time   TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  db_user      VARCHAR2(30),
  os_user      VARCHAR2(128),
  host         VARCHAR2(128),
  ip_address   VARCHAR2(64),
  ddl_event    VARCHAR2(30),
  object_type  VARCHAR2(30),
  object_name  VARCHAR2(128)
);

CREATE TABLE guard_ldd (
  obj_type       VARCHAR2(30)  NOT NULL,
  obj_name       VARCHAR2(128) NOT NULL,

  active         CHAR(1) DEFAULT 'Y' NOT NULL CHECK (active IN ('Y','N')),

  block_drop     CHAR(1) DEFAULT 'N' NOT NULL CHECK (block_drop IN ('Y','N')),
  block_truncate CHAR(1) DEFAULT 'N' NOT NULL CHECK (block_truncate IN ('Y','N')),
  block_alter    CHAR(1) DEFAULT 'N' NOT NULL CHECK (block_alter IN ('Y','N')),

  reason         VARCHAR2(4000),

  CONSTRAINT pk_guard_ldd PRIMARY KEY (obj_type, obj_name),

  -- majuscule by default pt comparatii
  CONSTRAINT ck_guard_upper CHECK (obj_type = UPPER(obj_type) AND obj_name = UPPER(obj_name)),

  -- interzise tabelele folosite de trigger in lista de guard
  CONSTRAINT ck_guard_no_infra CHECK (obj_name NOT IN ('AUDIT_DDL','AUDIT_LDD','GUARD_LDD','GUARD_DDL'))
);

CREATE OR REPLACE TRIGGER trg_audit_ddl
BEFORE DDL ON SCHEMA
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;

  v_event    VARCHAR2(30)  := ORA_SYSEVENT;
  v_type     VARCHAR2(30)  := ORA_DICT_OBJ_TYPE;
  v_name     VARCHAR2(128) := ORA_DICT_OBJ_NAME;

  v_bd CHAR(1);
  v_bt CHAR(1);
  v_ba CHAR(1);
BEGIN
  -- 1) AUDIT (nu vrem ca auditarea sa blocheze DDL-ul daca apar probleme)
  BEGIN
    INSERT INTO audit_ddl (db_user, os_user, host, ip_address, ddl_event, object_type, object_name)
    VALUES (
      SYS_CONTEXT('USERENV','SESSION_USER'),
      SYS_CONTEXT('USERENV','OS_USER'),
      SYS_CONTEXT('USERENV','HOST'),
      SYS_CONTEXT('USERENV','IP_ADDRESS'),
      v_event,
      v_type,
      v_name
    );
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      -- nu blocam DDL din cauza auditului
      NULL;
  END;

  -- 2) GUARD: nu protejam infrastructura (si nici nu vrem sa consultam guard pe ea)
  IF UPPER(v_name) IN ('AUDIT_DDL','AUDIT_LDD','GUARD_LDD','GUARD_DDL') THEN
    RETURN;
  END IF;

  -- 3) Citim regulile de guard (daca exista)
  BEGIN
    SELECT block_drop, block_truncate, block_alter
    INTO   v_bd,       v_bt,          v_ba
    FROM guard_ldd
    WHERE active   = 'Y'
      AND obj_type = UPPER(v_type)
      AND obj_name = UPPER(v_name);
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN; -- nu e protejat
    WHEN OTHERS THEN
      RETURN; -- daca guard-ul are probleme, nu blocam DDL
  END;

  -- 4) Aplicam blocarea doar pe evenimentul cerut
  IF v_event = 'DROP' AND v_bd = 'Y' THEN
    RAISE_APPLICATION_ERROR(-20050, 'DDL blocat de GUARD_LDD: DROP pe '||v_type||' '||v_name);
  ELSIF v_event = 'TRUNCATE' AND v_bt = 'Y' THEN
    RAISE_APPLICATION_ERROR(-20051, 'DDL blocat de GUARD_LDD: TRUNCATE pe '||v_type||' '||v_name);
  ELSIF v_event = 'ALTER' AND v_ba = 'Y' THEN
    RAISE_APPLICATION_ERROR(-20052, 'DDL blocat de GUARD_LDD: ALTER pe '||v_type||' '||v_name);
  END IF;

END;
/





-- ------------------------------------------------------------
-- Demonstratii
-- ------------------------------------------------------------

-- 10.)

SET SERVEROUTPUT ON;

DECLARE
  v_sala   NUMBER;
  v_ang    NUMBER;
  v_cli    NUMBER;

  v_evt_A  NUMBER; -- pentru conflict cu rezervari
  v_evt_B1 NUMBER; -- conflict eveniment-eveniment
  v_evt_B2 NUMBER;

  PROCEDURE ok(p_msg VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [OK] '||p_msg); END;
  PROCEDURE fail(p_msg VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [FAIL] '||p_msg); END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST TRIGGER 10 =================');
  SAVEPOINT sp10;

  -- setup minim
  INSERT INTO Sali (nume_sala, capacitate)
  VALUES ('Sala_T10', 20)
  RETURNING id_sala INTO v_sala;

  INSERT INTO Angajati (nume, prenume, functie, salariu, mail)
  VALUES ('Test', 'Ang_T10', 'Chelner', 3000, 't10_ang_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3')||'@ex.com')
  RETURNING id_angajat INTO v_ang;

  INSERT INTO Clienti (nume, prenume, nr_tel, mail)
  VALUES ('Test', 'Client_T10', '0700000000', 't10_c_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3')||'@ex.com')
  RETURNING id_client INTO v_cli;

  -- (1) conflict planificare vs rezervari (astept ORA-20011)
  DBMS_OUTPUT.PUT_LINE('--- (1) Conflict cu REZERVARI (astept ORA-20011) ---');

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST', DATE '2026-02-10', 5)
  RETURNING id_eveniment INTO v_evt_A;

  INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala)
  VALUES (DATE '2026-02-10', '18:00', 2, v_cli, v_sala);

  BEGIN
    INSERT INTO Planificari_organizatorice (id_eveniment, id_sala, id_angajat, observatii)
    VALUES (v_evt_A, v_sala, v_ang, 'conflict rezervari');
    fail('NU a respins (ar fi trebuit ORA-20011).');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -20011 THEN ok('Respins corect: '||SQLERRM);
      ELSE fail('Eroare diferita: '||SQLERRM);
      END IF;
  END;

  -- (2) conflict planificare vs alt eveniment (astept ORA-20010)
  DBMS_OUTPUT.PUT_LINE('--- (2) Conflict cu ALT EVENIMENT (astept ORA-20010) ---');

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST', DATE '2026-02-12', 5)
  RETURNING id_eveniment INTO v_evt_B1;

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST', DATE '2026-02-12', 5)
  RETURNING id_eveniment INTO v_evt_B2;

  -- prima planificare OK
  INSERT INTO Planificari_organizatorice (id_eveniment, id_sala, id_angajat, observatii)
  VALUES (v_evt_B1, v_sala, v_ang, 'primul eveniment');

  -- a doua planificare trebuie respinsa
  BEGIN
    INSERT INTO Planificari_organizatorice (id_eveniment, id_sala, id_angajat, observatii)
    VALUES (v_evt_B2, v_sala, v_ang, 'al doilea eveniment');
    fail('NU a respins (ar fi trebuit ORA-20010).');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -20010 THEN ok('Respins corect: '||SQLERRM);
      ELSE fail('Eroare diferita: '||SQLERRM);
      END IF;
  END;

  ROLLBACK TO sp10;
  DBMS_OUTPUT.PUT_LINE('============== FINAL TEST TRIGGER 10 (rollback) ==============');
END;
/




-- 11.)

SET SERVEROUTPUT ON;

DECLARE
  v_sala   NUMBER;
  v_ang    NUMBER;
  v_cli1   NUMBER;
  v_cli2   NUMBER;
  v_evt    NUMBER;
  v_rez_ok NUMBER;

  PROCEDURE ok(p_msg VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [OK] '||p_msg); END;
  PROCEDURE fail(p_msg VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [FAIL] '||p_msg); END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('================= TEST TRIGGER 11 (ROW - conflict eveniment) =================');
  SAVEPOINT sp11;

  -- setup minim
  INSERT INTO Sali (nume_sala, capacitate)
  VALUES ('Sala_T11', 10)
  RETURNING id_sala INTO v_sala;

  INSERT INTO Angajati (nume, prenume, functie, salariu, mail)
  VALUES ('Test', 'Ang_T11', 'Chelner', 3000, 't11_ang_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3')||'@ex.com')
  RETURNING id_angajat INTO v_ang;

  INSERT INTO Clienti (nume, prenume, nr_tel, mail)
  VALUES ('Test', 'Client1_T11', '0700000000', 't11_c1_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3')||'@ex.com')
  RETURNING id_client INTO v_cli1;

  INSERT INTO Clienti (nume, prenume, nr_tel, mail)
  VALUES ('Test', 'Client2_T11', '0711111111', 't11_c2_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3')||'@ex.com')
  RETURNING id_client INTO v_cli2;

  -- Cream un eveniment pe 2026-02-15 in sala v_sala
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES ('TEST', DATE '2026-02-15', 8)
  RETURNING id_eveniment INTO v_evt;

  INSERT INTO Planificari_organizatorice (id_eveniment, id_sala, id_angajat, observatii)
  VALUES (v_evt, v_sala, v_ang, 'blocare rezervari');

  -- (1) rezervare respinsa din cauza evenimentului (astept ORA-20021)
  DBMS_OUTPUT.PUT_LINE('--- (1) Conflict cu EVENIMENT (astept ORA-20021) ---');
  BEGIN
    INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala)
    VALUES (DATE '2026-02-15', '19:00', 2, v_cli1, v_sala);

    fail('NU a respins (ar fi trebuit ORA-20021).');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -20021 THEN ok('Respins corect: '||SQLERRM);
      ELSE fail('Eroare diferita: '||SQLERRM);
      END IF;
  END;

  -- (2) rezervare OK intr-o zi fara eveniment
  DBMS_OUTPUT.PUT_LINE('--- (2) Rezervare OK (fara eveniment) ---');
  BEGIN
    INSERT INTO Rezervari (data_rezervare, ora_rezervare, numar_persoane, id_client, id_sala)
    VALUES (DATE '2026-02-20', '18:00', 3, v_cli1, v_sala)
    RETURNING id_rezervare INTO v_rez_ok;

    ok('Inserare reusita (id_rezervare='||v_rez_ok||').');
  EXCEPTION
    WHEN OTHERS THEN
      fail('NU ar fi trebuit sa dea eroare: '||SQLERRM);
  END;

  -- (3) UPDATE catre o zi cu eveniment (astept ORA-20021)
  DBMS_OUTPUT.PUT_LINE('--- (3) UPDATE catre zi cu eveniment (astept ORA-20021) ---');
  BEGIN
    UPDATE Rezervari
    SET data_rezervare = DATE '2026-02-15'
    WHERE id_rezervare = v_rez_ok;

    fail('NU a respins UPDATE-ul (ar fi trebuit ORA-20021).');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -20021 THEN ok('Respins corect la UPDATE: '||SQLERRM);
      ELSE fail('Eroare diferita: '||SQLERRM);
      END IF;
  END;

  ROLLBACK TO sp11;
  DBMS_OUTPUT.PUT_LINE('============== FINAL TEST TRIGGER 11 (rollback) ==============');
END;
/



-- 12.) 

SET SERVEROUTPUT ON;

DECLARE
  PROCEDURE ok(p VARCHAR2)   IS BEGIN DBMS_OUTPUT.PUT_LINE('  [OK] '||p); END;
  PROCEDURE fail(p VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [FAIL] '||p); END;
BEGIN

  DBMS_OUTPUT.PUT_LINE('================= TEST CERINTA 12 (AUDIT + GUARD) =================');

  DBMS_OUTPUT.PUT_LINE('--- (0) NU ai voie sa adaugi AUDIT_DDL in GUARD_LDD (astept ORA-02290) ---');
  BEGIN
    INSERT INTO guard_ldd(obj_type, obj_name, block_drop) VALUES ('TABLE','AUDIT_DDL','Y');
    fail('A permis inserarea AUDIT_DDL in GUARD_LDD.');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -2290 THEN ok('Blocare corecta (check constraint): '||SQLERRM);
      ELSE fail('Eroare diferita: '||SQLERRM);
      END IF;
  END;
  ROLLBACK;

  DBMS_OUTPUT.PUT_LINE('--- (0b) NU ai voie sa adaugi GUARD_LDD in GUARD_LDD (astept ORA-02290) ---');
  BEGIN
    INSERT INTO guard_ldd(obj_type, obj_name, block_drop) VALUES ('TABLE','GUARD_LDD','Y');
    fail('A permis inserarea GUARD_LDD in GUARD_LDD.');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -2290 THEN ok('Blocare corecta (check constraint): '||SQLERRM);
      ELSE fail('Eroare diferita: '||SQLERRM);
      END IF;
  END;
  ROLLBACK;

  -- Curatam (daca exista) tabela de test
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE t_guard_test PURGE';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;

  DBMS_OUTPUT.PUT_LINE('--- (1) CREATE TABLE t_guard_test (trebuie sa mearga) ---');
  BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE t_guard_test (id NUMBER)';
    ok('CREATE TABLE reusit.');
  EXCEPTION
    WHEN OTHERS THEN fail('Nu trebuia eroare: '||SQLERRM);
  END;

  DBMS_OUTPUT.PUT_LINE('--- (2) Protejam tabela (block_drop=Y) ---');
  INSERT INTO guard_ldd(obj_type, obj_name, active, block_drop, block_truncate, block_alter, reason)
  VALUES ('TABLE','T_GUARD_TEST','Y','Y','N','N','Test protectie DROP');
  COMMIT;
  ok('Regula GUARD_LDD inserata.');

  DBMS_OUTPUT.PUT_LINE('--- (3) DROP TABLE protejat (astept ORA-20050) ---');
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE t_guard_test PURGE';
    fail('NU trebuia sa permita DROP (era protejata).');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -20050 THEN ok('Blocare corecta: '||SQLERRM);
      ELSE 
        IF INSTR(DBMS_UTILITY.FORMAT_ERROR_STACK, 'ORA-20050') > 0 THEN
        ok('Blocare corecta: ORA-20050 apare in stack (e wrapped in alte exceptii).');
        ELSE
          fail('Eroare diferita: '||SQLERRM);
          DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_STACK);
        END IF;
      END IF;
  END;

  DBMS_OUTPUT.PUT_LINE('--- (4) Dezactivam protectia si incercam din nou DROP (trebuie sa mearga) ---');
  UPDATE guard_ldd
  SET active='N'
  WHERE obj_type='TABLE' AND obj_name='T_GUARD_TEST';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE t_guard_test PURGE';
    ok('DROP TABLE reusit dupa dezactivarea guard.');
  EXCEPTION
    WHEN OTHERS THEN fail('Nu trebuia eroare: '||SQLERRM);
  END;

  DBMS_OUTPUT.PUT_LINE('--- (5) Ultimele intrari din AUDIT_DDL (top 10) ---');
  FOR r IN (
    SELECT id, event_time, ddl_event, object_type, object_name, db_user
    FROM audit_ddl
    ORDER BY id DESC
    FETCH FIRST 10 ROWS ONLY
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('   #'||r.id||' | '||
      TO_CHAR(r.event_time,'YYYY-MM-DD HH24:MI:SS')||' | '||
      r.ddl_event||' | '||r.object_type||' '||r.object_name||' | '||r.db_user);
  END LOOP;
  
  DBMS_OUTPUT.PUT_LINE('--- (6) SEQUENCE + DROP ---');

  BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_guard_test'; EXCEPTION WHEN OTHERS THEN NULL; END;
  DELETE FROM guard_ldd WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_TEST';

  EXECUTE IMMEDIATE 'CREATE SEQUENCE seq_guard_test START WITH 1 INCREMENT BY 1';

  INSERT INTO guard_ldd(obj_type, obj_name, active, block_drop, block_truncate, block_alter, reason)
  VALUES ('SEQUENCE','SEQ_GUARD_TEST','Y','Y','N','N','Seq DROP blocat');
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP SEQUENCE seq_guard_test';
    fail('(6.a) NU trebuia sa permita DROP SEQUENCE.');
  EXCEPTION
    WHEN OTHERS THEN
      IF INSTR(DBMS_UTILITY.FORMAT_ERROR_STACK,'ORA-20050')>0 THEN
        ok('(6.a) Blocare corecta (ORA-20050 in stack).');
      ELSE
        fail('(6.a) Eroare diferita: '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      END IF;
  END;

  UPDATE guard_ldd SET active='N'
  WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_TEST';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP SEQUENCE seq_guard_test';
    ok('(6.b) DROP permis corect (active=N).');
  EXCEPTION
    WHEN OTHERS THEN fail('(6.b) DROP trebuia sa mearga: '||SQLERRM);
  END;

  EXECUTE IMMEDIATE 'CREATE SEQUENCE seq_guard_test START WITH 1 INCREMENT BY 1';

  UPDATE guard_ldd SET active='Y', block_drop='N'
  WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_TEST';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP SEQUENCE seq_guard_test';
    ok('(6.c) DROP permis corect (block_drop=N).');
  EXCEPTION
    WHEN OTHERS THEN fail('(6.c) DROP trebuia sa mearga: '||SQLERRM);
  END;

  DELETE FROM guard_ldd WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_TEST';
  COMMIT;


  DBMS_OUTPUT.PUT_LINE('--- (7) SEQUENCE + ALTER ---');

  BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_guard_alter'; EXCEPTION WHEN OTHERS THEN NULL; END;
  DELETE FROM guard_ldd WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_ALTER';

  EXECUTE IMMEDIATE 'CREATE SEQUENCE seq_guard_alter START WITH 1 INCREMENT BY 1';

  INSERT INTO guard_ldd(obj_type, obj_name, active, block_drop, block_truncate, block_alter, reason)
  VALUES ('SEQUENCE','SEQ_GUARD_ALTER','Y','N','N','Y','Seq ALTER blocat');
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'ALTER SEQUENCE seq_guard_alter INCREMENT BY 5';
    fail('(7.a) NU trebuia sa permita ALTER SEQUENCE.');
  EXCEPTION
    WHEN OTHERS THEN
      IF INSTR(DBMS_UTILITY.FORMAT_ERROR_STACK,'ORA-20052')>0 THEN
        ok('(7.a) Blocare corecta (ORA-20052 in stack).');
      ELSE
        fail('(7.a) Eroare diferita: '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      END IF;
  END;

  UPDATE guard_ldd SET active='N'
  WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_ALTER';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'ALTER SEQUENCE seq_guard_alter INCREMENT BY 5';
    ok('(7.b) ALTER permis corect (active=N).');
  EXCEPTION
    WHEN OTHERS THEN fail('(7.b) ALTER trebuia sa mearga: '||SQLERRM);
  END;

  UPDATE guard_ldd SET active='Y', block_alter='N'
  WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_ALTER';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'ALTER SEQUENCE seq_guard_alter INCREMENT BY 2';
    ok('(7.c) ALTER permis corect (block_alter=N).');
  EXCEPTION
    WHEN OTHERS THEN fail('(7.c) ALTER trebuia sa mearga: '||SQLERRM);
  END;

  BEGIN EXECUTE IMMEDIATE 'DROP SEQUENCE seq_guard_alter'; EXCEPTION WHEN OTHERS THEN NULL; END;
  DELETE FROM guard_ldd WHERE obj_type='SEQUENCE' AND obj_name='SEQ_GUARD_ALTER';
  COMMIT;


  DBMS_OUTPUT.PUT_LINE('--- (8) VIEW + DROP ---');

  BEGIN EXECUTE IMMEDIATE 'DROP VIEW v_guard_test'; EXCEPTION WHEN OTHERS THEN NULL; END;
  DELETE FROM guard_ldd WHERE obj_type='VIEW' AND obj_name='V_GUARD_TEST';

  EXECUTE IMMEDIATE 'CREATE OR REPLACE VIEW v_guard_test AS SELECT 1 AS x FROM dual';

  INSERT INTO guard_ldd(obj_type, obj_name, active, block_drop, block_truncate, block_alter, reason)
  VALUES ('VIEW','V_GUARD_TEST','Y','Y','N','N','View DROP blocat');
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP VIEW v_guard_test';
    fail('(8.a) NU trebuia sa permita DROP VIEW.');
  EXCEPTION
    WHEN OTHERS THEN
      IF INSTR(DBMS_UTILITY.FORMAT_ERROR_STACK,'ORA-20050')>0 THEN
        ok('(8.a) Blocare corecta (ORA-20050 in stack).');
      ELSE
        fail('(8.a) Eroare diferita: '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      END IF;
  END;

  UPDATE guard_ldd SET active='N'
  WHERE obj_type='VIEW' AND obj_name='V_GUARD_TEST';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP VIEW v_guard_test';
    ok('(8.b) DROP permis corect (active=N).');
  EXCEPTION
    WHEN OTHERS THEN fail('(8.b) DROP trebuia sa mearga: '||SQLERRM);
  END;

  EXECUTE IMMEDIATE 'CREATE OR REPLACE VIEW v_guard_test AS SELECT 1 AS x FROM dual';

  UPDATE guard_ldd SET active='Y', block_drop='N'
  WHERE obj_type='VIEW' AND obj_name='V_GUARD_TEST';
  COMMIT;

  BEGIN
    EXECUTE IMMEDIATE 'DROP VIEW v_guard_test';
    ok('(8.c) DROP permis corect (block_drop=N).');
  EXCEPTION
    WHEN OTHERS THEN fail('(8.c) DROP trebuia sa mearga: '||SQLERRM);
  END;

  DELETE FROM guard_ldd WHERE obj_type='VIEW' AND obj_name='V_GUARD_TEST';
  COMMIT;
  
  DBMS_OUTPUT.PUT_LINE('--- (5) Ultimele intrari din AUDIT_DDL (top 20) ---');
  FOR r IN (
    SELECT id, event_time, ddl_event, object_type, object_name, db_user
    FROM audit_ddl
    ORDER BY id DESC
    FETCH FIRST 20 ROWS ONLY
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('   #'||r.id||' | '||
      TO_CHAR(r.event_time,'YYYY-MM-DD HH24:MI:SS')||' | '||
      r.ddl_event||' | '||r.object_type||' '||r.object_name||' | '||r.db_user);
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('================= FINAL TEST CERINTA 12 =================');

END;
/





















-- Exercitiul 13

























SET SERVEROUTPUT ON;

--------------------------------------------------------------------------------
-- PACHET: PKG_GESTIUNE_STOC
-- Flux: analiza -> comanda (in memorie) -> receptie (update Produse) -> raport
--------------------------------------------------------------------------------

BEGIN
  EXECUTE IMMEDIATE 'DROP PACKAGE pkg_gestiune_stoc';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
CREATE OR REPLACE PACKAGE pkg_gestiune_stoc AS
  ------------------------------------------------------------------------------
  -- Tipuri complexe: record + nested table + associative array (map)
  ------------------------------------------------------------------------------
  TYPE t_linie_analiza IS RECORD(
    id_produs         Produse.id_produs%TYPE,
    nume_produs       Produse.nume_produs%TYPE,
    unitate_masura    Produse.unitate_masura%TYPE,
    stoc_curent       Produse.cantitate%TYPE,
    necesar_eveniment NUMBER,
    cerere_orizont    NUMBER,
    tinta_stoc        NUMBER,
    deficit           NUMBER,
    recomandare       VARCHAR2(20) -- 'COMANDA' / 'NU_COMANDA'
  );

  TYPE t_lista_analiza IS TABLE OF t_linie_analiza;

  -- o "comand" in memorie pentru un produs
  TYPE t_comanda_produs IS RECORD(
    id_produs      Produse.id_produs%TYPE,
    nume_produs    Produse.nume_produs%TYPE,
    unitate_masura Produse.unitate_masura%TYPE,
    cantitate      NUMBER, -- cantitatea ce va fi adaugata la stoc la receptie
    id_eveniment   Evenimente.id_eveniment%TYPE,
    data_evt       DATE,
    orizont_zile   NUMBER,
    buffer_pct     NUMBER,
    created_at     TIMESTAMP
  );

  -- map: id_produs -> comanda pending (1 per produs)
  TYPE t_comenzi_map IS TABLE OF t_comanda_produs INDEX BY PLS_INTEGER;

  ------------------------------------------------------------------------------
  -- Functii
  ------------------------------------------------------------------------------
  FUNCTION f_data_eveniment(p_id_eveniment IN NUMBER) RETURN DATE;

  FUNCTION f_cerere_produs_orizont(
    p_id_produs  IN NUMBER,
    p_data_start IN DATE,
    p_data_end   IN DATE
  ) RETURN NUMBER;

  FUNCTION f_analiza_eveniment(
    p_id_eveniment IN NUMBER,
    p_orizont_zile IN NUMBER DEFAULT 0,
    p_buffer_pct   IN NUMBER DEFAULT 0
  ) RETURN t_lista_analiza;

  ------------------------------------------------------------------------------
  -- Proceduri (flux)
  ------------------------------------------------------------------------------
  PROCEDURE p_genereaza_comenzi(
    p_id_eveniment IN NUMBER,
    p_orizont_zile IN NUMBER DEFAULT 0,
    p_buffer_pct   IN NUMBER DEFAULT 0
  );

  PROCEDURE p_raport_eveniment(
    p_id_eveniment IN NUMBER,
    p_orizont_zile IN NUMBER DEFAULT 0,
    p_buffer_pct   IN NUMBER DEFAULT 0
  );

  PROCEDURE p_raport_comenzi_curente;

  -- receptie/anulare per produs
  PROCEDURE p_receptioneaza_comanda_produs(p_id_produs IN NUMBER);
  PROCEDURE p_anuleaza_comanda_produs(p_id_produs IN NUMBER);

  -- utilitare: receptie/anulare pentru toate comenzile pending
  PROCEDURE p_receptioneaza_toate;
  PROCEDURE p_anuleaza_toate;

END pkg_gestiune_stoc;
/
SHOW ERRORS;

CREATE OR REPLACE PACKAGE BODY pkg_gestiune_stoc AS

  -- stare in memorie (pe sesiune): comenzi multiple, cheie = id_produs
  g_comenzi t_comenzi_map;

  PROCEDURE validate_params(p_id_eveniment NUMBER, p_orizont_zile NUMBER, p_buffer_pct NUMBER) IS
  BEGIN
    IF p_id_eveniment IS NULL OR p_orizont_zile IS NULL OR p_buffer_pct IS NULL
       OR p_orizont_zile < 0 OR p_buffer_pct < 0 OR p_buffer_pct > 100 THEN
      RAISE_APPLICATION_ERROR(-20102, 'Parametri invalizi (orizont>=0, buffer 0..100).');
    END IF;
  END;

  FUNCTION f_data_eveniment(p_id_eveniment IN NUMBER) RETURN DATE IS
    v_d DATE;
  BEGIN
    SELECT data_eveniment INTO v_d
    FROM Evenimente
    WHERE id_eveniment = p_id_eveniment;
    RETURN v_d;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20100, 'Eveniment inexistent (id_eveniment='||p_id_eveniment||').');
  END;

  FUNCTION f_cerere_produs_orizont(
    p_id_produs  IN NUMBER,
    p_data_start IN DATE,
    p_data_end   IN DATE
  ) RETURN NUMBER IS
    v_sum NUMBER;
  BEGIN
    SELECT NVL(SUM(ep.cantitate), 0)
    INTO   v_sum
    FROM   Evenimente_Produse ep
    JOIN   Evenimente e ON e.id_eveniment = ep.id_eveniment
    WHERE  ep.id_produs = p_id_produs
      AND  TRUNC(e.data_eveniment) >= TRUNC(p_data_start)
      AND  TRUNC(e.data_eveniment) <= TRUNC(p_data_end);

    RETURN v_sum;
  END;

  FUNCTION f_analiza_eveniment(
    p_id_eveniment IN NUMBER,
    p_orizont_zile IN NUMBER DEFAULT 0,
    p_buffer_pct   IN NUMBER DEFAULT 0
  ) RETURN t_lista_analiza IS
    v_data_evt DATE;
    v_list t_lista_analiza := t_lista_analiza();
    v_cnt NUMBER;
  BEGIN
    validate_params(p_id_eveniment, p_orizont_zile, p_buffer_pct);

    v_data_evt := f_data_eveniment(p_id_eveniment);

    SELECT COUNT(*) INTO v_cnt
    FROM Evenimente_Produse
    WHERE id_eveniment = p_id_eveniment;

    IF v_cnt = 0 THEN
      RAISE_APPLICATION_ERROR(-20101, 'Eveniment fara produse asociate (Evenimente_Produse).');
    END IF;

    SELECT
      p.id_produs,
      p.nume_produs,
      p.unitate_masura,
      p.cantitate AS stoc_curent,
      ep.cantitate AS necesar_eveniment,
      f_cerere_produs_orizont(p.id_produs, v_data_evt, v_data_evt + p_orizont_zile) AS cerere_orizont,
      CAST(NULL AS NUMBER) AS tinta_stoc,
      CAST(NULL AS NUMBER) AS deficit,
      CAST(NULL AS VARCHAR2(20)) AS recomandare
    BULK COLLECT INTO v_list
    FROM Evenimente_Produse ep
    JOIN Produse p ON p.id_produs = ep.id_produs
    WHERE ep.id_eveniment = p_id_eveniment
    ORDER BY p.id_produs;

    FOR i IN 1 .. v_list.COUNT LOOP
      v_list(i).tinta_stoc :=
        CEIL(
          GREATEST(v_list(i).necesar_eveniment, v_list(i).cerere_orizont)
          * (1 + p_buffer_pct/100)
        );

      v_list(i).deficit := v_list(i).tinta_stoc - v_list(i).stoc_curent;

      IF v_list(i).deficit > 0 THEN
        v_list(i).recomandare := 'COMANDA';
      ELSE
        v_list(i).deficit := 0;
        v_list(i).recomandare := 'NU_COMANDA';
      END IF;
    END LOOP;

    RETURN v_list;
  END;

  PROCEDURE p_raport_eveniment(
    p_id_eveniment IN NUMBER,
    p_orizont_zile IN NUMBER DEFAULT 0,
    p_buffer_pct   IN NUMBER DEFAULT 0
  ) IS
    v_list t_lista_analiza;
    v_data DATE;
  BEGIN
    v_data := f_data_eveniment(p_id_eveniment);
    v_list := f_analiza_eveniment(p_id_eveniment, p_orizont_zile, p_buffer_pct);

    DBMS_OUTPUT.PUT_LINE('============================================================');
    DBMS_OUTPUT.PUT_LINE('RAPORT STOC - Eveniment #'||p_id_eveniment||
                         ' | Data='||TO_CHAR(v_data,'YYYY-MM-DD')||
                         ' | Orizont='||p_orizont_zile||' | Buffer='||p_buffer_pct||'%');
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');

    FOR i IN 1 .. v_list.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(
        'Produs #'||v_list(i).id_produs||' '||RPAD(v_list(i).nume_produs, 20)||
        ' stoc='||TO_CHAR(v_list(i).stoc_curent)||
        ' necesar_evt='||TO_CHAR(v_list(i).necesar_eveniment)||
        ' cerere_oriz='||TO_CHAR(v_list(i).cerere_orizont)||
        ' tinta='||TO_CHAR(v_list(i).tinta_stoc)||
        ' deficit='||TO_CHAR(v_list(i).deficit)||
        ' -> '||v_list(i).recomandare
      );
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('============================================================');
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('[RAPORT] '||SQLERRM);
  END;

  PROCEDURE p_genereaza_comenzi(
    p_id_eveniment IN NUMBER,
    p_orizont_zile IN NUMBER DEFAULT 0,
    p_buffer_pct   IN NUMBER DEFAULT 0
  ) IS
    v_list t_lista_analiza;
    v_data_evt DATE;
    v_has_deficit BOOLEAN := FALSE;
    v_nr_create PLS_INTEGER := 0;
    v_nr_ignorate PLS_INTEGER := 0;
  BEGIN
    validate_params(p_id_eveniment, p_orizont_zile, p_buffer_pct);
  
    v_data_evt := f_data_eveniment(p_id_eveniment);
    v_list := f_analiza_eveniment(p_id_eveniment, p_orizont_zile, p_buffer_pct);
  
    -- daca nu exista niciun deficit deloc -> comanda inutila
    FOR i IN 1 .. v_list.COUNT LOOP
      IF v_list(i).deficit > 0 THEN
        v_has_deficit := TRUE;
        EXIT;
      END IF;
    END LOOP;
  
    IF NOT v_has_deficit THEN
      RAISE_APPLICATION_ERROR(-20104, 'Stoc suficient raportat la necesar/orizont. Comanda inutila.');
    END IF;
  
    -- Adaugam comenzi doar pentru produsele fara comanda pending; restul se ignora (mesaj)
    FOR i IN 1 .. v_list.COUNT LOOP
      IF v_list(i).deficit > 0 THEN
  
        IF g_comenzi.EXISTS(v_list(i).id_produs) THEN
          v_nr_ignorate := v_nr_ignorate + 1;
          DBMS_OUTPUT.PUT_LINE(
            '[INFO] Produs #'||v_list(i).id_produs||' ('||v_list(i).nume_produs||') '||
            'are deja comanda pending. Pe analiza curenta (orizont='||p_orizont_zile||
            ', buffer='||p_buffer_pct||'%) deficit='||v_list(i).deficit||' -> IGNORAT.'
          );
        ELSE
          g_comenzi(v_list(i).id_produs).id_produs      := v_list(i).id_produs;
          g_comenzi(v_list(i).id_produs).nume_produs    := v_list(i).nume_produs;
          g_comenzi(v_list(i).id_produs).unitate_masura := v_list(i).unitate_masura;
          g_comenzi(v_list(i).id_produs).cantitate      := v_list(i).deficit;
          g_comenzi(v_list(i).id_produs).id_eveniment   := p_id_eveniment;
          g_comenzi(v_list(i).id_produs).data_evt       := v_data_evt;
          g_comenzi(v_list(i).id_produs).orizont_zile   := p_orizont_zile;
          g_comenzi(v_list(i).id_produs).buffer_pct     := p_buffer_pct;
          g_comenzi(v_list(i).id_produs).created_at     := SYSTIMESTAMP;
          v_nr_create := v_nr_create + 1;
        END IF;
  
      END IF;
    END LOOP;
  
    IF v_nr_create = 0 THEN
      DBMS_OUTPUT.PUT_LINE(
        '[COMENZI] Nu s-a adaugat nicio comanda noua pentru eveniment #'||p_id_eveniment||
        '. Produse cu deficit ignorate (aveau deja comanda): '||v_nr_ignorate||'.'
      );
      -- fluxul e ok, doar nu e nimic de adaugat
      RETURN;
    END IF;
  
    DBMS_OUTPUT.PUT_LINE(
      '[COMENZI] Adaugate '||v_nr_create||' comenzi noi in memorie pentru eveniment #'||p_id_eveniment||
      ' (orizont='||p_orizont_zile||', buffer='||p_buffer_pct||'%). '||
      'Ignorate (deja pending): '||v_nr_ignorate||'.'
    );
  
    p_raport_comenzi_curente;
  
  END;

  PROCEDURE p_raport_comenzi_curente IS
    k PLS_INTEGER;
    v_cnt PLS_INTEGER := 0;
  BEGIN
    IF g_comenzi.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('[COMENZI] (nu exista comenzi pending in memorie)');
      RETURN;
    END IF;

    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');
    DBMS_OUTPUT.PUT_LINE('COMENZI PENDING (1 / produs): '||g_comenzi.COUNT);
    k := g_comenzi.FIRST;
    WHILE k IS NOT NULL LOOP
      v_cnt := v_cnt + 1;
      DBMS_OUTPUT.PUT_LINE(
        '  ['||v_cnt||'] Produs #'||g_comenzi(k).id_produs||' '||RPAD(g_comenzi(k).nume_produs, 20)||
        ' cant='||TO_CHAR(g_comenzi(k).cantitate)||' '||g_comenzi(k).unitate_masura||
        ' | eveniment='||g_comenzi(k).id_eveniment||
        ' | data_evt='||TO_CHAR(g_comenzi(k).data_evt,'YYYY-MM-DD')||
        ' | orizont='||g_comenzi(k).orizont_zile||' | buffer='||g_comenzi(k).buffer_pct||'%'
      );
      k := g_comenzi.NEXT(k);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('------------------------------------------------------------');
  END;

  PROCEDURE p_receptioneaza_comanda_produs(p_id_produs IN NUMBER) IS
    v_q NUMBER;
    v_rows NUMBER;
  BEGIN
    IF p_id_produs IS NULL THEN
      RAISE_APPLICATION_ERROR(-20102, 'Parametru invalid: id_produs NULL.');
    END IF;

    IF NOT g_comenzi.EXISTS(p_id_produs) THEN
      RAISE_APPLICATION_ERROR(-20105, 'Nu exista comanda pending in memorie pentru produs #'||p_id_produs||'.');
    END IF;

    v_q := g_comenzi(p_id_produs).cantitate;

    UPDATE Produse
    SET cantitate = cantitate + v_q
    WHERE id_produs = p_id_produs;

    v_rows := SQL%ROWCOUNT;
    IF v_rows = 0 THEN
      RAISE_APPLICATION_ERROR(-20110, 'Produs inexistent in tabela Produse (id_produs='||p_id_produs||').');
    END IF;

    DBMS_OUTPUT.PUT_LINE('[RECEPTIE] Produs #'||p_id_produs||' + '||v_q||
                         ' (eveniment='||g_comenzi(p_id_produs).id_eveniment||'). Stoc actualizat.');

    g_comenzi.DELETE(p_id_produs);
  END;

  PROCEDURE p_anuleaza_comanda_produs(p_id_produs IN NUMBER) IS
  BEGIN
    IF p_id_produs IS NULL THEN
      RAISE_APPLICATION_ERROR(-20102, 'Parametru invalid: id_produs NULL.');
    END IF;

    IF g_comenzi.EXISTS(p_id_produs) THEN
      DBMS_OUTPUT.PUT_LINE('[ANULARE] S-a anulat comanda pending pentru produs #'||p_id_produs||
                           ' (eveniment='||g_comenzi(p_id_produs).id_eveniment||').');
      g_comenzi.DELETE(p_id_produs);
    ELSE
      DBMS_OUTPUT.PUT_LINE('[ANULARE] Nu exista comanda pending pentru produs #'||p_id_produs||'.');
    END IF;
  END;

  PROCEDURE p_receptioneaza_toate IS
    k PLS_INTEGER;
  BEGIN
    IF g_comenzi.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('[RECEPTIE] Nu exista comenzi pending.');
      RETURN;
    END IF;

    k := g_comenzi.FIRST;
    WHILE k IS NOT NULL LOOP
      -- salvam NEXT inainte de delete
      DECLARE nxt PLS_INTEGER;
      BEGIN
        nxt := g_comenzi.NEXT(k);
        p_receptioneaza_comanda_produs(k);
        k := nxt;
      END;
    END LOOP;
  END;

  PROCEDURE p_anuleaza_toate IS
  BEGIN
    g_comenzi.DELETE;
    DBMS_OUTPUT.PUT_LINE('[ANULARE] Toate comenzile pending au fost anulate.');
  END;

END pkg_gestiune_stoc;
/
SHOW ERRORS;

----------------
-- TESTE
----------------

SET SERVEROUTPUT ON;

DECLARE
  v_tip Evenimente.tip_eveniment%TYPE;

  -- Produse
  v_pA NUMBER; v_pB NUMBER; v_pC NUMBER; v_pD NUMBER; v_pE NUMBER;

  -- Evenimente
  v_e1 NUMBER; v_e2 NUMBER; v_e3 NUMBER; v_e4 NUMBER; v_e5 NUMBER; v_e6 NUMBER;
  v_tag VARCHAR2(50) := TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MISSFF3');

  PROCEDURE ok(p VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [OK] '||p); END;
  PROCEDURE fail(p VARCHAR2) IS BEGIN DBMS_OUTPUT.PUT_LINE('  [FAIL] '||p); END;

  FUNCTION stoc(p_id NUMBER) RETURN NUMBER IS v NUMBER;
  BEGIN SELECT cantitate INTO v FROM Produse WHERE id_produs = p_id; RETURN v; END;

BEGIN
  DBMS_OUTPUT.PUT_LINE('===================== TESTE =====================');
  SAVEPOINT sp_all;

  -- tip_eveniment existent
  BEGIN
    SELECT tip_eveniment INTO v_tip FROM Evenimente WHERE ROWNUM = 1;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    v_tip := 'TEST';
  END;

  -- Produse de test
  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('T_Prod_A_'||v_tag, 100, 'buc', 5) RETURNING id_produs INTO v_pA;

  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('T_Prod_B_'||v_tag, 2, 'buc', 10) RETURNING id_produs INTO v_pB;

  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('T_Prod_C_'||v_tag, 0, 'buc', 7) RETURNING id_produs INTO v_pC;

  ok('Produse create: A='||v_pA||', B='||v_pB||', C='||v_pC);

  -------------------------------------------------------------------
  -- (1) Stoc suficient -> -20104
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (1) Stoc suficient => astept -20104 ---');
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, DATE '2032-01-10', 10) RETURNING id_eveniment INTO v_e1;

  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate)
  VALUES (v_e1, v_pA, 10);

  BEGIN
    pkg_gestiune_stoc.p_genereaza_comenzi(v_e1, 0, 0);
    fail('Nu a blocat comanda desi stoc suficient.');
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -20104 THEN ok('Blocare corecta: '||SQLERRM);
      ELSE fail('Alta eroare: '||SQLERRM);
      END IF;
  END;

  -------------------------------------------------------------------
  -- (2) Deficit produs B -> creeaza comanda pending pentru B
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (2) Deficit B => creeaza comanda pending B ---');
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, DATE '2032-01-12', 10) RETURNING id_eveniment INTO v_e2;

  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate)
  VALUES (v_e2, v_pB, 10);

  pkg_gestiune_stoc.p_genereaza_comenzi(v_e2, 0, 0);
  ok('B pending creat. Stoc B inainte='||stoc(v_pB));

  -------------------------------------------------------------------
  -- (3) Cu B pending, deficit C -> permite comanda C in paralel
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (3) B pending + deficit C => creeaza si C ---');
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, DATE '2032-01-13', 10) RETURNING id_eveniment INTO v_e3;

  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate)
  VALUES (v_e3, v_pC, 5);

  pkg_gestiune_stoc.p_genereaza_comenzi(v_e3, 0, 0);
  ok('C pending creat in paralel cu B.');

  pkg_gestiune_stoc.p_raport_comenzi_curente;

  -------------------------------------------------------------------
  -- (4) daca produsul B are deja comanda, IGNORA B si creeaza comenzi pentru alte produse din eveniment.
  --     Cream produs D deficit + eveniment cu (B + D).
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (4) Eveniment cu (B deja pending) + D deficit => IGNORA B, creeaza D ---');
  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('T_Prod_D_'||v_tag, 0, 'buc', 3) RETURNING id_produs INTO v_pD;

  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, DATE '2032-01-14', 10) RETURNING id_eveniment INTO v_e4;

  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (v_e4, v_pB, 3);
  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (v_e4, v_pD, 4);

  -- AICI trebuie sa NU dea eroare
  BEGIN
    pkg_gestiune_stoc.p_genereaza_comenzi(v_e4, 0, 0);
    ok('A rulat fara eroare: B ignorat, D adaugat.');
  EXCEPTION
    WHEN OTHERS THEN
      fail('Nu trebuia sa dea eroare: '||SQLERRM);
  END;

  pkg_gestiune_stoc.p_raport_comenzi_curente;

  -------------------------------------------------------------------
  -- (5) Eveniment doar cu B (B pending, deficit) => NU creeaza nimic nou
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (5) Eveniment doar cu B pending => nu creeaza nimic nou ---');
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, DATE '2032-01-15', 10) RETURNING id_eveniment INTO v_e5;

  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (v_e5, v_pB, 4);

  BEGIN
    pkg_gestiune_stoc.p_genereaza_comenzi(v_e5, 0, 0);
    ok('A rulat: B ignorat, nicio comanda noua (corect).');
  EXCEPTION
    WHEN OTHERS THEN
      fail('Nu trebuia eroare aici: '||SQLERRM);
  END;

  -------------------------------------------------------------------
  -- (6) Receptie pe toate si verificare stocuri
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (6) Receptie pe toate (B, C, D) + verificare stoc ---');
  DBMS_OUTPUT.PUT_LINE('  Stoc inainte: B='||stoc(v_pB)||', C='||stoc(v_pC)||', D='||stoc(v_pD));
  pkg_gestiune_stoc.p_receptioneaza_toate;
  DBMS_OUTPUT.PUT_LINE('  Stoc dupa:    B='||stoc(v_pB)||', C='||stoc(v_pC)||', D='||stoc(v_pD));
  pkg_gestiune_stoc.p_raport_comenzi_curente;

  -------------------------------------------------------------------
  -- (7) TEST 7: 2 comenzi pe 2 produse diferite + buffering
  --     - una pe orizont+buffer
  --     - una pe eveniment: initial fara buffer, anulata, refacuta cu buffer
  --     - apoi receptie pe toate
  -------------------------------------------------------------------
  DBMS_OUTPUT.PUT_LINE('--- (7) 2 comenzi pe 2 produse diferite + buffering + receptie toate ---');

  -- curatam memoria
  pkg_gestiune_stoc.p_anuleaza_toate;

  -- Produs A2 (orizont): stoc 50, cerere orizont 100, buffer 10% => tinta 110 => deficit 60
  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('T7_Prod_A2_'||v_tag, 50, 'buc', 5) RETURNING id_produs INTO v_pA;

  -- Produs E (eveniment): stoc 0, necesar 10, refacut cu buffer 20% => tinta 12 => deficit 12
  INSERT INTO Produse (nume_produs, cantitate, unitate_masura, pret_unitar)
  VALUES ('T7_Prod_E_'||v_tag, 0, 'buc', 9) RETURNING id_produs INTO v_pE;

  -- Eveniment initiator orizont
  INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
  VALUES (v_tip, DATE '2033-02-01', 10) RETURNING id_eveniment INTO v_e6;
  INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (v_e6, v_pA, 40);

  -- Eveniment suplimentar in orizont (+14 zile)
  DECLARE v_e6b NUMBER;
  BEGIN
    INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
    VALUES (v_tip, DATE '2033-02-15', 10) RETURNING id_eveniment INTO v_e6b;
    INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (v_e6b, v_pA, 60);
  END;

  DBMS_OUTPUT.PUT_LINE('  (7.1) Generez ORIZONT+BUFFER (orizont=30, buffer=10) pentru A2');
  pkg_gestiune_stoc.p_genereaza_comenzi(v_e6, 30, 10);

  -- Eveniment pentru produs E
  DECLARE v_eE NUMBER;
  BEGIN
    INSERT INTO Evenimente (tip_eveniment, data_eveniment, numar_persoane)
    VALUES (v_tip, DATE '2033-03-01', 10) RETURNING id_eveniment INTO v_eE;
    INSERT INTO Evenimente_Produse (id_eveniment, id_produs, cantitate) VALUES (v_eE, v_pE, 10);

    DBMS_OUTPUT.PUT_LINE('  (7.2) Generez EVENIMENT (buffer=0) pentru E');
    pkg_gestiune_stoc.p_genereaza_comenzi(v_eE, 0, 0);

    DBMS_OUTPUT.PUT_LINE('  (7.3) Anulez comanda E si regenerez cu buffer=20');
    pkg_gestiune_stoc.p_anuleaza_comanda_produs(v_pE);
    pkg_gestiune_stoc.p_genereaza_comenzi(v_eE, 0, 20);
  END;

  DBMS_OUTPUT.PUT_LINE('  (7.4) Comenzi pending (ambele trebuie sa arate buffer in detalii):');
  pkg_gestiune_stoc.p_raport_comenzi_curente;

  DBMS_OUTPUT.PUT_LINE('  (7.5) Receptie pe toate separat + verificare stoc:');
  DBMS_OUTPUT.PUT_LINE('    Stoc inainte: A2='||stoc(v_pA)||', E='||stoc(v_pE));
  pkg_gestiune_stoc.p_receptioneaza_comanda_produs(v_pE);
  pkg_gestiune_stoc.p_receptioneaza_comanda_produs(v_pA);
  DBMS_OUTPUT.PUT_LINE('    Stoc dupa:    A2='||stoc(v_pA)||', E='||stoc(v_pE));
  pkg_gestiune_stoc.p_raport_comenzi_curente;

  -- curatenie
  pkg_gestiune_stoc.p_anuleaza_toate;

  ROLLBACK TO sp_all;
  DBMS_OUTPUT.PUT_LINE('===================== FINAL TESTE (rollback) =====================');

EXCEPTION
  WHEN OTHERS THEN
    fail('Eroare neasteptata in teste: '||SQLERRM);
    BEGIN pkg_gestiune_stoc.p_anuleaza_toate; EXCEPTION WHEN OTHERS THEN NULL; END;
    ROLLBACK TO sp_all;
END;
/









